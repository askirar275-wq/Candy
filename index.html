<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Candy Match — Smooth Swap</title>
<style>
:root{
  --cols:8; --rows:8; --gap:6px; --tile:64px; --accent:#ff4d9e;
  --swap-dur:180ms; --fall-dur:320ms; --pop-dur:260ms;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
.stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
.card{width:100%;max-width:980px;padding:18px;border-radius:14px;background:#fff;box-shadow:0 18px 48px rgba(20,20,50,.06);display:flex;flex-direction:column;gap:12px}
.header{display:flex;align-items:center;justify-content:space-between}
.title{font-weight:900;font-size:20px}
.hud{display:flex;gap:12px;align-items:center}
.pill{background:#fff;padding:8px 12px;border-radius:20px;box-shadow:0 8px 18px rgba(20,20,60,.04);font-weight:800}
.grid-wrap{background:linear-gradient(180deg,#fff,#fff7fb);padding:12px;border-radius:12px;box-shadow:inset 0 8px 30px rgba(250,240,250,.4)}
.grid{display:grid; gap:var(--gap); grid-template-columns: repeat(var(--cols), var(--tile)); grid-auto-rows: var(--tile); justify-content:center; align-content:center; position:relative;}
.cell{width:var(--tile);height:var(--tile);border-radius:14px;background:linear-gradient(180deg,#fff,#fffefc);display:flex;align-items:center;justify-content:center;box-shadow:0 6px 14px rgba(10,10,30,0.06);overflow:visible;position:relative;border:1px solid rgba(0,0,0,0.04)}
.cell button { all:unset; width:100%; height:100%; display:block; border-radius:12px; cursor:grab; position:relative; }
.tile-img{ width:78%; height:78%; object-fit:contain; display:block; pointer-events:none; transform:translateZ(0); transition: transform var(--swap-dur) cubic-bezier(.2,.9,.2,1);}
.tile-moving{ transition: transform var(--swap-dur) cubic-bezier(.2,.9,.2,1); }
.pop{ animation: pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards; }
@keyframes pop{0%{transform:scale(1);opacity:1}45%{transform:scale(1.35)}100%{transform:scale(0);opacity:0}}
.controls{display:flex;gap:12px;justify-content:center;padding:10px}
.btn{padding:10px 16px;border-radius:14px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
.footer{display:flex;align-items:center;justify-content:space-between;padding-top:6px}
.note{font-size:12px;color:#666}
@media(max-width:720px){
  :root{ --tile:52px; --gap:4px; }
  .card{padding:14px}
}
</style>
</head>
<body>
  <div class="stage">
    <div class="card">
      <div class="header">
        <div><div class="title">Candy Match — Smooth</div><div class="note">Images from /images/</div></div>
        <div class="hud"><div class="pill">Score <span id="score">0</span></div><div class="pill">Moves <span id="moves">40</span></div></div>
      </div>

      <div class="grid-wrap">
        <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
      </div>

      <div class="controls">
        <button id="restart" class="btn primary">Restart</button>
        <button id="shuffle" class="btn">Shuffle</button>
        <button id="bomb" class="btn">Place Bomb</button>
      </div>

      <div class="footer">
        <div class="note">Put your images in <code>images/</code> (names in script)</div>
        <div></div>
      </div>
    </div>
  </div>

<script>
/* Smooth swap version — key points:
   - state.board holds tile objects (id + src)
   - swap animation uses transform on DOM elements, then we swap state
   - no new/random replacement during swap; new tiles are created ONLY in refill step
*/

const COLS = 8, ROWS = 8, SIZE = COLS*ROWS;
const IMAGE_PATH = 'images/'; // your github images folder
const IMAGE_NAMES = ['candy1.png','candy2.png','candy3.png','candy4.png','candy5.png','candy6.png','candy7.png','candy8.png'];
const BOMB_IMG = 'bomb.jpg'; // optional

const gridEl = document.getElementById('grid');
let state = { nextId:1, board: [], score:0, moves:40 };
let cells = []; // DOM containers
let locked=false;
let pointer = {down:false, startIdx:null, id:null};

function makeTile(src){
  return { id: state.nextId++, src: src || randomSrc(), power:null };
}
function randomSrc(){ return IMAGE_PATH + IMAGE_NAMES[Math.floor(Math.random()*IMAGE_NAMES.length)]; }

/* create grid DOM */
function createGrid(){
  gridEl.innerHTML = '';
  cells = [];
  gridEl.style.setProperty('--cols', COLS);
  for(let i=0;i<SIZE;i++){
    const cell = document.createElement('div'); cell.className='cell'; cell.dataset.index = i;
    const btn = document.createElement('button');
    btn.dataset.index = i;
    btn.addEventListener('pointerdown', onPointerDown);
    // don't add pointermove globally here; we'll use elementFromPoint on pointer move
    const img = document.createElement('img'); img.className='tile-img'; img.alt='candy';
    btn.appendChild(img);
    cell.appendChild(btn);
    gridEl.appendChild(cell);
    cells.push({cell, btn, img});
  }
}

/* render all tiles from state.board (do not create random tiles here) */
function renderAll(dropMap){
  for(let i=0;i<SIZE;i++){
    const tile = state.board[i];
    const {cell, btn, img} = cells[i];
    // clear text nodes if any
    cell.childNodes.forEach(n=>{ if(n.nodeType===3) n.remove(); });
    if(tile){
      img.src = tile.src;
      img.dataset.src = tile.src;
      img.style.visibility = 'visible';
      cell.style.visibility = 'visible';
    } else {
      img.src = '';
      img.dataset.src = '';
      img.style.visibility = 'hidden';
      cell.style.visibility = 'hidden';
    }
    // clear transforms
    img.style.transition = '';
    img.style.transform = '';
    img.classList.remove('tile-moving','pop');
    // dropMap handled by transform on cell
    if(dropMap && tile && dropMap[tile.id]){
      cell.style.transform = `translateY(${dropMap[tile.id]})`;
      requestAnimationFrame(()=> requestAnimationFrame(()=> { cell.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`; cell.style.transform = ''; }));
    } else {
      cell.style.transform = '';
      cell.style.transition = '';
    }
  }
  updateHUD();
}

/* update HUD */
function updateHUD(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('moves').textContent = state.moves;
}

/* init board with no immediate matches */
function initBoard(){
  state.nextId = 1;
  state.board = new Array(SIZE).fill(null).map(()=> makeTile());
  // avoid initial matches by regenerating until no matches
  let tries=0;
  while(findMatches(state.board).length>0 && tries++<800){
    state.board = new Array(SIZE).fill(null).map(()=> makeTile());
  }
  state.score = 0; state.moves = 40;
  renderAll();
}

/* helpers: indices */
function rc(i){ return {r: Math.floor(i/COLS), c: i%COLS}; }
function idx(r,c){ return r*COLS + c; }

/* find matches (by src) */
function findMatches(boardArr){
  const matches = [];
  // horizontal
  for(let r=0;r<ROWS;r++){
    let run=[r*COLS];
    for(let c=1;c<COLS;c++){
      const p = r*COLS + c -1, i = r*COLS + c;
      if(boardArr[i] && boardArr[p] && boardArr[i].src === boardArr[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let run=[c];
    for(let r=1;r<ROWS;r++){
      const p = (r-1)*COLS + c, i = r*COLS + c;
      if(boardArr[i] && boardArr[p] && boardArr[i].src === boardArr[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* gravity + refill - NEW tiles created here only */
function applyGravityAndRefill(){
  const cols = [];
  for(let c=0;c<COLS;c++){
    const col=[];
    for(let r=ROWS-1;r>=0;r--){
      const i = idx(r,c);
      if(state.board[i]) col.push(state.board[i]);
    }
    cols.push(col);
  }
  const newBoard = new Array(SIZE).fill(null);
  const dropMap = {};
  const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
  const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
  for(let c=0;c<COLS;c++){
    const col = cols[c];
    while(col.length < ROWS) col.push(makeTile()); // NEW created here
    for(let r=ROWS-1,i=0;r>=0;r--,i++){
      const tile = col[i];
      newBoard[idx(r,c)] = tile;
      if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
    }
  }
  state.board = newBoard;
  renderAll(dropMap);
}

/* remove set of indices (add pop animation), then gravity/refill */
function removeAndCollapse(indices){
  // play pop animation
  indices.forEach(i=>{
    const el = cells[i].cell;
    const img = cells[i].img;
    img.classList.add('pop');
    // set invisible after pop duration
    setTimeout(()=>{ state.board[i] = null; renderAll(); }, 260);
  });
  // after pop delay, apply gravity AND refill (so new tiles only appear here)
  setTimeout(()=> applyGravityAndRefill(), 320);
}

/* resolve chain (recursively) */
function resolveChain(){
  if(locked) return;
  locked = true;
  (function loop(){
    const matches = findMatches(state.board);
    if(matches.length===0){ locked=false; updateHUD(); return; }
    // merge matches indices
    const removeSet = new Set();
    matches.forEach(run=> run.forEach(i=> removeSet.add(i)));
    const rem = Array.from(removeSet);
    // scoring
    state.score += rem.length * 12;
    updateHUD();
    removeAndCollapse(rem);
    // after gravity+refill completes, check again
    setTimeout(()=> setTimeout(loop, 260), 380);
  })();
}

/* SWAP animation helper:
   - animate two cells by translate transforms (using their bounding rects)
   - after animation, swap state.board and render
   - return promise that resolves when animation done
*/
function animateSwap(i,j){
  return new Promise(resolve=>{
    const aCell = cells[i].cell, bCell = cells[j].cell;
    const aRect = aCell.getBoundingClientRect(), bRect = bCell.getBoundingClientRect();
    const dx = bRect.left - aRect.left, dy = bRect.top - aRect.top;
    // apply transform to images (so they slide visually)
    const aImg = cells[i].img, bImg = cells[j].img;
    // bring to front
    aImg.style.zIndex = 1000; bImg.style.zIndex = 1000;
    aImg.classList.add('tile-moving'); bImg.classList.add('tile-moving');
    aImg.style.transform = `translate(${dx}px, ${dy}px)`;
    bImg.style.transform = `translate(${-dx}px, ${-dy}px)`;
    // after duration, clear transform and swap state
    setTimeout(()=>{
      aImg.style.transition = ''; bImg.style.transition = '';
      aImg.style.transform = ''; bImg.style.transform = '';
      aImg.classList.remove('tile-moving'); bImg.classList.remove('tile-moving');
      aImg.style.zIndex = ''; bImg.style.zIndex = '';
      // swap underlying tile objects
      [state.board[i], state.board[j]] = [state.board[j], state.board[i]];
      renderAll();
      resolve();
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--swap-dur')) || 180);
  });
}

/* Input handling: pointerdown + elementFromPoint trick on move */
function onPointerDown(e){
  if(locked) return;
  const el = e.currentTarget;
  pointer.down = true;
  pointer.startIdx = Number(el.dataset.index);
  pointer.id = e.pointerId;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
async function onPointerMove(e){
  if(!pointer.down || e.pointerId !== pointer.id) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cellEl = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cellEl) return;
  const idx = Number(cellEl.dataset.index);
  if(Number.isNaN(idx) || idx === pointer.startIdx) return;
  if(!isAdjacent(pointer.startIdx, idx)) return;
  // do swap animation and logic
  document.removeEventListener('pointermove', onPointerMove); // freeze further moves until done
  // animate
  await animateSwap(pointer.startIdx, idx);
  state.moves = Math.max(0, state.moves-1);
  updateHUD();
  const matches = findMatches(state.board);
  if(matches.length>0){
    resolveChain();
  } else {
    // revert swap with animation and restore
    await animateSwap(pointer.startIdx, idx); // animate back (because state was swapped once)
  }
  pointer.down = false; pointer.startIdx = null; pointer.id = null;
  document.removeEventListener('pointerup', onPointerUp);
  document.addEventListener('pointermove', onPointerMove);
}
function onPointerUp(e){
  pointer.down = false; pointer.startIdx = null; pointer.id = null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){
  if(a==null || b==null) return false;
  const r1 = Math.floor(a/COLS), c1 = a%COLS, r2 = Math.floor(b/COLS), c2 = b%COLS;
  return Math.abs(r1-r2) + Math.abs(c1-c2) === 1;
}

/* controls */
document.getElementById('restart').addEventListener('click', ()=> { initBoard(); });
document.getElementById('shuffle').addEventListener('click', ()=> {
  // shuffle preserving tiles
  const temp = state.board.slice();
  for(let i=temp.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [temp[i], temp[j]] = [temp[j], temp[i]]; }
  state.board = temp;
  renderAll();
});
document.getElementById('bomb').addEventListener('click', ()=>{
  if(locked) return;
  const valid = state.board.map((t,i)=> t?i:-1).filter(i=>i>=0);
  if(valid.length===0) return;
  const idx = valid[Math.floor(Math.random()*valid.length)];
  state.board[idx] = makeTile(IMAGE_PATH + BOMB_IMG);
  renderAll();
  setTimeout(()=> {
    const rem = new Set();
    const r0 = Math.floor(idx/COLS), c0 = idx%COLS;
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      const nr=r0+dr, nc=c0+dc;
      if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS) rem.add(idx(nr,nc));
    }
    removeAndCollapse(Array.from(rem));
  }, 220);
});

/* start */
createGrid();
initBoard();
updateHUD();
</script>
</body>
</html>
