<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Candy Crush ‚Äî Advance Demo (SVG candies)</title>
<style>
:root{
  --cols:8; --rows:8; --gap:4px; --tile:64px;
  --accent:#ff4d9e; --pop-dur:300ms; --fall-dur:320ms;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#111}
.stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
.card{width:100%;max-width:980px;padding:14px;border-radius:14px;background:#fff;box-shadow:0 30px 80px rgba(20,20,50,.06);display:flex;flex-direction:column;gap:12px;overflow:hidden}
header{display:flex;align-items:center;justify-content:space-between}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:28px}
.hud{display:flex;gap:12px;align-items:center}
.pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:8px 12px;border-radius:999px;font-weight:800;box-shadow:0 10px 28px rgba(20,20,60,0.04)}
.content{display:flex;flex-direction:column;gap:8px;flex:1 1 auto;min-height:0}
.grid-area{flex:1 1 auto;display:flex;align-items:center;justify-content:center;min-height:0;padding:6px}
.grid-wrap{width:100%;max-width:860px;border-radius:12px;background:linear-gradient(180deg,#fff,#fff7fb);padding:10px;display:flex;align-items:center;justify-content:center;position:relative;box-shadow:inset 0 8px 30px rgba(250,240,250,0.4);overflow:hidden}
.grid{display:grid;gap:var(--gap);grid-template-columns:repeat(var(--cols), var(--tile));grid-auto-rows:var(--tile);justify-content:center;align-content:center;touch-action:none;user-select:none}
.cell{width:var(--tile);height:var(--tile);border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#fffefc);box-shadow:0 6px 14px rgba(10,10,30,0.06);cursor:grab;position:relative;overflow:visible;border:1px solid rgba(0,0,0,0.04);padding:0}
.cell svg{width:78%;height:78%;display:block;pointer-events:none}
.power-icon{position:absolute;right:6px;top:6px;font-size:12px;pointer-events:none}
.cell.pop{animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
@keyframes pop{0%{transform:scale(1);opacity:1}45%{transform:scale(1.4)}100%{transform:scale(0);opacity:0}}
.controls{display:flex;gap:10px;align-items:center;justify-content:center;padding:8px 6px}
.btn{padding:10px 14px;border-radius:12px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
.footer{display:flex;align-items:center;justify-content:space-between;padding:8px 6px}
.progress{height:14px;width:240px;background:#eee;border-radius:999px;overflow:hidden}
.progress i{display:block;height:100%;width:0;background:linear-gradient(90deg,#ff9ac8,#ff6aa8);transition:width 320ms ease}

/* small screens */
@media(max-width:720px){
  :root{ --tile:52px; --gap:3px; }
  .card{padding:10px}
}
.modal-bg{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(10,10,20,0.45);display:none;align-items:center;justify-content:center;z-index:60}
.modal{width:92%;max-width:480px;background:#fff;border-radius:12px;padding:14px;box-shadow:0 30px 80px rgba(10,10,30,0.25)}
.level-win{font-weight:900;color:var(--accent);font-size:20px;text-align:center}
</style>
</head>
<body>
  <div class="stage">
    <div class="card" id="card">
      <header>
        <div class="brand">
          <div class="logo">üç¨</div>
          <div>
            <div style="font-weight:900;font-size:18px">Candy Crush ‚Äî Advance</div>
            <div style="font-size:12px;color:#666">SVG candies ‚Äî no external images required</div>
          </div>
        </div>

        <div class="hud">
          <div class="pill">Level <span id="level">1</span></div>
          <div class="pill">Score <span id="score">0</span></div>
          <div class="pill">Moves <span id="moves">40</span></div>
        </div>
      </header>

      <div class="content">
        <div class="grid-area">
          <div id="gridWrap" class="grid-wrap">
            <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
          </div>
        </div>

        <div class="controls">
          <button id="restart" class="btn primary">Restart</button>
          <button id="shuffle" class="btn">Shuffle</button>
          <button id="useBomb" class="btn">Place Bomb</button>
        </div>
      </div>

      <div class="footer">
        <div id="comboText" style="font-weight:900;color:var(--accent)">Combo √ó1</div>
        <div class="progress"><i id="progressBar"></i></div>
      </div>
    </div>
  </div>

  <!-- Modal for level win -->
  <div id="modalBg" class="modal-bg" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" id="modal">
      <div class="level-win" id="levelTitle">‡§≤‡•á‡§µ‡§≤ ‡§™‡•Ç‡§∞‡§æ ‡§π‡•Å‡§Ü üéâ</div>
      <p id="levelMsg" style="color:#444;text-align:center;margin-top:8px">‡§Ü‡§™‡§®‡•á ‡§≤‡§ï‡•ç‡§∑‡•ç‡§Ø ‡§™‡•Ç‡§∞‡§æ ‡§ï‡§∞ ‡§≤‡§ø‡§Ø‡§æ ‡§π‡•à‡•§ ‡§Ö‡§ó‡§≤‡§æ ‡§≤‡•á‡§µ‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç‡•§</p>
      <div style="display:flex;justify-content:center;margin-top:12px">
        <button id="continueBtn" class="btn primary">Next Level</button>
      </div>
    </div>
  </div>

<script>
/* ====== Advance Candy Crush style (single-file, SVG candies) ======
   Features:
   - Inline SVG candies (10 types) ‚Äî no image files needed
   - Specials: bomb, striped (row/col), rainbow (clear all of type)
   - Single-swap-per-drag, smooth pop/fall cycle
   - Level target system: target = level * 800
   - Modal on level complete
*/

/* CONFIG */
const WIDTH = 8, HEIGHT = 8, SIZE = WIDTH * HEIGHT;
const TILE_GAP = 4;
const BASE_MOVES = 40;

/* candy types (10) */
const TYPES = ['c1','c2','c3','c4','c5','c6','c7','c8','c9','c10'];

/* game state */
const gridEl = document.getElementById('grid');
let state = { nextId:1, board:[], score:0, moves:BASE_MOVES, combo:1, level:1 };
let CELL = []; // {button,img?}
let locked=false, dragging=false, pointerId=null, lastIndex=null, swappedThisDrag=false;

/* Utility: return SVG markup for a candy type and power */
function candySVG(type, power){
  // base color palette for 10 candies
  const palette = {
    c1: ['#ff6b6b','#ff4757'],
    c2: ['#ffd93d','#ffb84d'],
    c3: ['#ff8c42','#ff6a00'],
    c4: ['#9b59b6','#7d3c98'],
    c5: ['#7bed9f','#2ed573'],
    c6: ['#ff7eb6','#ff6b9a'],
    c7: ['#4bcffa','#0abde3'],
    c8: ['#f8a5c2','#f78fb3'],
    c9: ['#f6e58d','#ffbe76'],
    c10:['#c7ecee','#7ed6df']
  };
  const p = palette[type] || ['#eee','#ddd'];
  // make a glossy candy circle with central swirl
  let svg = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
    <defs>
      <radialGradient id="g-${type}" cx="30%" cy="30%" r="80%">
        <stop offset="0%" stop-color="${p[0]}"/>
        <stop offset="100%" stop-color="${p[1]}"/>
      </radialGradient>
      <filter id="s-${type}" x="-20%" y="-20%" width="140%" height="140%">
        <feGaussianBlur stdDeviation="2" result="b"/>
        <feBlend in="SourceGraphic" in2="b"/>
      </filter>
    </defs>
    <g filter="url(#s-${type})">
      <circle cx="50" cy="50" r="44" fill="url(#g-${type})" stroke="rgba(255,255,255,0.28)" stroke-width="2"/>
      <path d="M30 38 Q50 28 70 38" stroke="rgba(255,255,255,0.55)" stroke-width="4" fill="none" stroke-linecap="round" opacity="0.9"/>
      <path d="M28 58 Q50 48 72 58" stroke="rgba(255,255,255,0.25)" stroke-width="6" fill="none" stroke-linecap="round" opacity="0.8"/>
      <circle cx="42" cy="38" r="6" fill="rgba(255,255,255,0.75)" opacity="0.9"/>
    </g>`;

  // special power overlay icons (small)
  if(power && power.type === 'bomb'){
    svg += `<g><text x="50" y="58" text-anchor="middle" font-size="36">üí£</text></g>`;
  } else if(power && power.type === 'stripe'){
    // horizontal or vertical
    if(power.dir === 'h'){
      svg += `<rect x="12" y="46" width="76" height="12" rx="6" fill="rgba(255,255,255,0.85)"/>`;
    } else {
      svg += `<rect x="46" y="12" width="12" height="76" rx="6" fill="rgba(255,255,255,0.85)"/>`;
    }
  } else if(power && power.type === 'color'){
    svg += `<g><text x="50" y="56" text-anchor="middle" font-size="40">‚òÖ</text></g>`;
  }

  svg += `</svg>`;
  return svg;
}

/* Create grid cells once */
function createCells(){
  gridEl.innerHTML = '';
  CELL = [];
  gridEl.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    btn.innerHTML = ''; // we will set innerHTML to svg later
    btn.addEventListener('pointerdown', onPointerDown);
    gridEl.appendChild(btn);
    CELL.push({button:btn});
  }
}

/* make tile object */
function makeTile(type){
  return { id: state.nextId++, type: type || TYPES[Math.floor(Math.random()*TYPES.length)], power: null };
}
function randTile(){ return makeTile(); }

/* render board (fast) */
function render(dropMap){
  for(let i=0;i<SIZE;i++){
    if(!state.board[i]) state.board[i] = randTile();
    const tile = state.board[i];
    const el = CELL[i].button;
    // set svg
    const power = tile.power;
    const svg = candySVG(tile.type, power);
    el.innerHTML = svg + (power ? `<div class="power-icon">${ power.type==='bomb' ? 'üí£' : (power.type==='color' ? '‚òÖ' : (power.type==='stripe' ? (power.dir==='h'?'‚Äî':'‚îÇ') : '')) }</div>` : '');
    el.dataset.type = tile.type;
    // animate dropped tiles
    if(dropMap && dropMap[tile.id]){
      el.style.transform = `translateY(${dropMap[tile.id]})`;
      requestAnimationFrame(()=> requestAnimationFrame(()=> { el.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`; el.style.transform = 'translateY(0)'; }));
    } else {
      el.style.transition = '';
      el.style.transform = '';
    }
    el.classList.remove('pop');
  }
  updateHUD();
}

/* find matches by type */
function findMatches(bd){
  const matches = [];
  // rows
  for(let r=0;r<HEIGHT;r++){
    let run=[r*WIDTH];
    for(let c=1;c<WIDTH;c++){
      const p=r*WIDTH+c-1, i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].type === bd[p].type) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // cols
  for(let c=0;c<WIDTH;c++){
    let run=[c];
    for(let r=1;r<HEIGHT;r++){
      const p=(r-1)*WIDTH+c, i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].type === bd[p].type) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* detect specials to create where appropriate */
function detectSpecials(matches){
  const assign = {};
  matches.forEach(run=>{
    if(run.length >= 5){
      const idx = run[Math.floor(run.length/2)];
      assign[idx] = { type:'color' }; // rainbow
    } else if(run.length === 4){
      const a = run[0], b = run[1];
      const isH = Math.floor(a/WIDTH) === Math.floor(b/WIDTH);
      const idx = run[Math.floor(run.length/2)];
      assign[idx] = { type:'stripe', dir: isH ? 'h' : 'v' };
    }
  });
  return assign;
}

/* small particle burst */
function burst(x,y,amount=10){
  amount = Math.min(12, amount);
  const rect = gridEl.getBoundingClientRect();
  const ox = x - rect.left, oy = y - rect.top;
  for(let i=0;i<amount;i++){
    const p = document.createElement('div');
    p.style.position='absolute'; p.style.left=ox+'px'; p.style.top=oy+'px';
    const size = 6 + Math.random()*10; p.style.width=p.style.height=size+'px';
    p.style.borderRadius='50%'; p.style.background = `rgba(255,90,140,${0.4+Math.random()*0.4})`; p.style.pointerEvents='none';
    gridEl.parentElement.appendChild(p);
    const angle = Math.random()*Math.PI*2; const dist = 20 + Math.random()*60;
    const nx = Math.cos(angle)*dist, ny = Math.sin(angle)*dist;
    p.animate([{transform:'translate(-50%,-50%) scale(1)', opacity:1},{transform:`translate(-50%,-50%) translate(${nx}px,${ny}px) scale(.3)`, opacity:0}], {duration:600+Math.random()*300, easing:'cubic-bezier(.2,.8,.2,1)'});
    setTimeout(()=>p.remove(),1100);
  }
}

/* apply special power */
function activatePowerAt(idx, otherType=null){
  const tile = state.board[idx];
  if(!tile || !tile.power) return;
  const p = tile.power;
  const removed = new Set();
  if(p.type === 'stripe'){
    if(p.dir === 'h'){ const r = Math.floor(idx/WIDTH); for(let c=0;c<WIDTH;c++) removed.add(r*WIDTH + c); }
    else { const c = idx % WIDTH; for(let r=0;r<HEIGHT;r++) removed.add(r*WIDTH + c); }
  } else if(p.type === 'bomb'){
    const r0 = Math.floor(idx/WIDTH), c0 = idx%WIDTH;
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      const nr=r0+dr, nc=c0+dc;
      if(nr>=0&&nr<HEIGHT&&nc>=0&&nc<WIDTH) removed.add(nr*WIDTH+nc);
    }
  } else if(p.type === 'color'){
    const target = otherType || tile.type;
    for(let i=0;i<state.board.length;i++) if(state.board[i] && state.board[i].type === target) removed.add(i);
  }
  const arr = Array.from(removed);
  arr.forEach(i=>{ const el = CELL[i].button; if(el) el.classList.add('pop'); state.board[i] = null; });
  state.score += arr.length * 14; saveState();
  setTimeout(()=> resolveChain(), 360);
}

/* color bomb helper (swap with regular) */
function activateColorBomb(idx, targetType){
  const target = targetType || (state.board[idx] && state.board[idx].type);
  if(!target) return;
  let removed=0;
  for(let i=0;i<state.board.length;i++){
    if(state.board[i] && state.board[i].type === target){ state.board[i] = null; removed++; const el = CELL[i].button; if(el) el.classList.add('pop'); }
  }
  state.score += removed*12; saveState();
  setTimeout(()=> resolveChain(), 300);
}

/* main chain resolution (pop -> gravity -> refill -> repeat) */
function resolveChain(){
  if(locked) return;
  locked = true;
  state.combo = 1;
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length === 0){ locked = false; updateHUD(); saveState(); checkLevelComplete(); return; }
    const specialMap = detectSpecials(matches);
    const removeSet = new Set();
    matches.forEach(run => run.forEach(i => removeSet.add(i)));
    const removeIdx = Array.from(removeSet).sort((a,b)=>a-b);
    const removedCount = removeIdx.length;
    state.score += removedCount * 12 * state.combo;
    state.combo++;
    updateHUD();

    // pop anim + particles
    let cx=0, cy=0, cnt=0;
    removeIdx.forEach(i=>{
      const el = CELL[i] && CELL[i].button;
      if(el){ const rc = el.getBoundingClientRect(); cx+=rc.left+rc.width/2; cy+=rc.top+rc.height/2; cnt++; el.classList.add('pop'); }
      state.board[i] = null;
    });
    if(cnt>0) burst(cx/cnt, cy/cnt, Math.min(28, 6+cnt));

    setTimeout(()=>{
      // gravity + refill with dropMap
      const cols = [];
      for(let c=0;c<WIDTH;c++){
        const col = [];
        for(let r=HEIGHT-1;r>=0;r--){ const idx = r*WIDTH+c; if(state.board[idx]) col.push(state.board[idx]); }
        cols.push(col);
      }
      const newBoard = new Array(SIZE).fill(null);
      const dropMap = {};
      const tilePx = Math.max(36, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64);
      const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
      for(let c=0;c<WIDTH;c++){
        const col = cols[c];
        while(col.length < HEIGHT) col.push(randTile());
        for(let r=HEIGHT-1,i=0;r>=0;r--,i++){
          const tile = col[i];
          newBoard[r*WIDTH+c] = tile;
          if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
        }
      }

      // place specials
      Object.keys(specialMap).forEach(k=>{
        const idx = Number(k);
        if(newBoard[idx]) newBoard[idx].power = specialMap[k];
        else {
          const pos = newBoard.findIndex(x=>x);
          if(pos>=0) newBoard[pos].power = specialMap[k];
        }
      });

      state.board = newBoard;
      render(dropMap);
      saveState();

      // loop
      setTimeout(()=> setTimeout(step, 220), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fall-dur')) || 320);
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 300);
  })();
}

/* Pointer handlers: single-swap-per-drag */
function onPointerDown(e){
  if(locked) return;
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true;
  pointerId = e.pointerId;
  lastIndex = Number(el.dataset.index);
  swappedThisDrag = false;
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  if(swappedThisDrag) return; // only one swap per drag
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
    // perform swap
    swapIndices(lastIndex, idx);
    render();
    state.moves = Math.max(0, state.moves-1);
    updateHUD();
    swappedThisDrag = true;

    // handle special-power interactions
    const A = state.board[idx], B = state.board[lastIndex];
    if(A && A.power && A.power.type === 'color'){ activateColorBomb(idx, B ? B.type : null); return; }
    if(B && B.power && B.power.type === 'color'){ activateColorBomb(lastIndex, A ? A.type : null); return; }
    if(A && A.power){ activatePowerAt(idx, B ? B.type : null); return; }
    if(B && B.power){ activatePowerAt(lastIndex, A ? A.type : null); return; }

    const matches = findMatches(state.board);
    if(matches.length > 0) resolveChain();
    else {
      // revert after small delay (visual feedback)
      setTimeout(()=>{ swapIndices(lastIndex, idx); render(); }, 220);
    }
  }
}
function onPointerUp(e){
  dragging = false;
  pointerId = null;
  lastIndex = null;
  swappedThisDrag = false;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){ if(a==null||b==null) return false; const r1=Math.floor(a/WIDTH), c1=a%WIDTH, r2=Math.floor(b/WIDTH), c2=b%WIDTH; return Math.abs(r1-r2)+Math.abs(c1-c2)===1; }
function swapIndices(i,j){ [state.board[i], state.board[j]] = [state.board[j], state.board[i]]; }

/* Hint / findHint (optional) */
function findHint(){
  for(let i=0;i<state.board.length;i++){
    const r=Math.floor(i/WIDTH), c=i%WIDTH;
    const dirs=[[0,1],[1,0],[0,-1],[-1,0]];
    for(const d of dirs){
      const nr=r+d[0], nc=c+d[1];
      if(nr<0||nr>=HEIGHT||nc<0||nc>=WIDTH) continue;
      const j = nr*WIDTH + nc;
      swapIndices(i,j);
      const m = findMatches(state.board);
      swapIndices(i,j);
      if(m.length>0) return [i,j];
    }
  }
  return null;
}

/* HUD & persistence */
function updateHUD(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('moves').textContent = state.moves;
  document.getElementById('level').textContent = state.level;
  document.getElementById('comboText').textContent = `Combo √ó${Math.max(1, state.combo-1)}`;
  document.getElementById('progressBar').style.width = Math.min(100, Math.round((state.score % (state.level*800)) / (state.level*8))) + '%';
}

/* level complete check */
function checkLevelComplete(){
  const target = state.level * 800;
  if(state.score >= target){
    // show modal
    const modalBg = document.getElementById('modalBg');
    document.getElementById('levelTitle').textContent = `‡§≤‡•á‡§µ‡§≤ ${state.level} ‡§™‡•Ç‡§∞‡§æ ‡§π‡•Å‡§Ü üéâ`;
    document.getElementById('levelMsg').textContent = `‡§Ü‡§™‡§®‡•á ${state.score} ‡§∏‡•ç‡§ï‡•ã‡§∞ ‡§ï‡§∞ ‡§≤‡§ø‡§è ‚Äî ‡§Ö‡§ó‡§≤‡§æ ‡§≤‡•á‡§µ‡§≤ ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç`;
    modalBg.style.display = 'flex';
    modalBg.setAttribute('aria-hidden','false');
    // continue button increases level & gives bonus moves
    document.getElementById('continueBtn').onclick = ()=>{
      modalBg.style.display = 'none';
      modalBg.setAttribute('aria-hidden','true');
      state.level++;
      state.moves += 12;
      state.combo = 1;
      // optionally increase difficulty: add more candy types or change target
      updateHUD();
    };
  }
}

/* Save/Load (localStorage) */
const STORAGE_KEY = 'candy_crush_advance_v1';
function saveState(){
  try{
    const s = { score: state.score, level: state.level };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(s));
  }catch(e){}
}
function loadState(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    if(!raw) return;
    const s = JSON.parse(raw);
    if(typeof s.score === 'number') state.score = s.score;
    if(typeof s.level === 'number') state.level = s.level;
  }catch(e){}
}

/* Use Bomb button - place a bomb tile and detonate */
document.getElementById('useBomb').addEventListener('click', ()=>{
  if(locked) return;
  const valid = state.board.map((t,i)=> t ? i : -1).filter(i=> i>=0);
  if(valid.length === 0) return;
  const idx = valid[Math.floor(Math.random()*valid.length)];
  state.board[idx] = makeTile(null);
  state.board[idx].power = { type:'bomb' };
  render();
  setTimeout(()=> {
    activatePowerAt(idx);
  }, 260);
});

/* shuffle & restart */
document.getElementById('shuffle').addEventListener('click', ()=>{
  state.board.sort(()=>Math.random()-0.5);
  render();
});
document.getElementById('restart').addEventListener('click', ()=> initBoard(true));

/* init board ensuring no immediate matches */
function initBoard(resetScore=false){
  state.nextId = 1;
  state.board = new Array(SIZE).fill(null).map(()=> randTile() );
  let tries=0;
  while(findMatches(state.board).length>0 && tries++ < 800){
    state.board = new Array(SIZE).fill(null).map(()=> randTile() );
  }
  if(resetScore){ state.score = 0; state.moves = BASE_MOVES; state.level = 1; state.combo = 1; }
  fitTiles(); render();
  updateHUD();
  saveState();
}

/* resize-fitting for responsive tiles */
function fitTiles(){
  const gap = Math.max(2, TILE_GAP);
  const cardRect = document.getElementById('card').getBoundingClientRect();
  const headerH = document.querySelector('header').getBoundingClientRect().height;
  const controlsH = document.querySelector('.controls') ? document.querySelector('.controls').getBoundingClientRect().height : 56;
  const footerH = document.querySelector('.footer').getBoundingClientRect().height;
  const padTop = parseFloat(getComputedStyle(document.getElementById('card')).paddingTop) || 0;
  const padBottom = parseFloat(getComputedStyle(document.getElementById('card')).paddingBottom) || 0;
  const availH = cardRect.height - headerH - controlsH - footerH - padTop - padBottom - 8;
  const availW = Math.min(gridEl.parentElement.getBoundingClientRect().width - 8, cardRect.width - 28);
  const candidateH = Math.floor((availH - gap*(HEIGHT-1)) / HEIGHT);
  const candidateW = Math.floor((availW - gap*(WIDTH-1)) / WIDTH);
  let base = Math.max(28, Math.min(candidateH, candidateW));
  if(base > 100) base = 100;
  document.documentElement.style.setProperty('--tile', (base) + 'px');
}

/* preload SVGs? (not needed since generated) */

/* Save on unload */
window.addEventListener('beforeunload', saveState);

/* debounce resize */
let rTO;
window.addEventListener('resize', ()=>{ clearTimeout(rTO); rTO = setTimeout(()=>{ fitTiles(); render(); }, 120); });

/* small helpers */
function saveState(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify({score:state.score,level:state.level})); }catch(e){} }
function loadState(){ try{ const v = localStorage.getItem(STORAGE_KEY); if(v){ const s = JSON.parse(v); if(s.score) state.score = s.score; if(s.level) state.level = s.level; } }catch(e){} }

/* start */
createCells();
loadState();
initBoard(true);
window._cm = { state, render, resolveChain, findHint, fitTiles };

</script>
</body>
</html>
