<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Candy Match ‚Äî Images + Levels</title>
<style>
:root{
  --cols:8; --rows:8; --gap:4px; --tile:72px; --accent:#ff4d9e;
  --pop-dur:320ms; --fall-dur:300ms; --ease:cubic-bezier(.2,.85,.18,1);
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff8fc,#eef7ff);color:#1b1230}
.stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
.card{width:100%;max-width:980px;height:calc(100vh - 24px);padding:14px;border-radius:14px;background:#fff;box-shadow:0 24px 70px rgba(20,20,60,.07);display:flex;flex-direction:column;gap:12px;overflow:hidden}
.header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:60px;height:60px;border-radius:14px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:30px}
.hud{display:flex;gap:12px;align-items:center}
.pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:10px 16px;border-radius:40px;font-weight:800;box-shadow:0 10px 28px rgba(20,20,60,0.04);text-align:center}
.meta{color:#666;font-size:13px}

.content{display:flex;gap:12px;flex:1 1 auto;min-height:0}
.gridWrap{flex:1 1 0;display:flex;align-items:center;justify-content:center;padding:10px;background:linear-gradient(180deg,#fff,#fff9ff);border-radius:12px;box-shadow:inset 0 10px 28px rgba(250,240,250,.4);max-height:calc(100vh - 240px);overflow:hidden;position:relative}
.grid{display:grid;gap:var(--gap);grid-template-columns:repeat(var(--cols), var(--tile));grid-auto-rows:var(--tile);touch-action:none;user-select:none;transform-origin:center center;transition:transform .18s var(--ease)}
.cell{width:var(--tile);height:var(--tile);border-radius:16px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#fffefc);box-shadow:0 10px 26px rgba(10,10,30,0.06);cursor:grab;position:relative;overflow:visible;border:1px solid rgba(0,0,0,0.04);transition:transform .12s var(--ease), box-shadow .12s}
.cell img{width:78%;height:78%;object-fit:contain;pointer-events:none;display:block}
.tile-emoji{display:block;pointer-events:none;transform:translateZ(0)}
.cell.pop{animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
@keyframes pop{0%{transform:scale(1);opacity:1}45%{transform:scale(1.45)}100%{transform:scale(0);opacity:0}}

.controls{width:300px;display:flex;flex-direction:column;gap:12px}
.controls .row{display:flex;gap:8px}
.btn{padding:12px 14px;border-radius:12px;border:0;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06);font-weight:800}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
.small{padding:8px 10px;border-radius:10px;font-weight:700}
.progress{height:12px;background:#eee;border-radius:999px;overflow:hidden}
.progress > i{display:block;height:100%;width:0;background:linear-gradient(90deg,#ff9ac8,#ff6aa8);transition:width .35s}
.particles{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;overflow:visible;z-index:3}
.levelBadge{background:linear-gradient(90deg,#fff,#fff9f0);padding:6px 10px;border-radius:10px;font-weight:900;color:#b0286f}

@media(max-width:720px){
  :root{ --tile:56px; --gap:3px }
  .controls{width:auto;flex-direction:row;justify-content:center}
  .card{padding:10px}
}
</style>
</head>
<body>
  <div class="stage">
    <div class="card" id="card">
      <div class="header">
        <div class="brand">
          <div class="logo">üç¨</div>
          <div>
            <div style="font-weight:900;font-size:20px">Candy Match ‚Äî Images & Levels</div>
            <div class="meta">Real images from GitHub + Level system</div>
          </div>
        </div>
        <div class="hud">
          <div class="pill"><small>Level</small><div id="level">1</div></div>
          <div class="pill"><small>Score</small><div id="score">0</div></div>
          <div class="pill"><small>Moves</small><div id="moves">40</div></div>
        </div>
      </div>

      <div class="content">
        <div class="gridWrap">
          <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
          <div id="particles" class="particles"></div>
        </div>

        <div class="controls">
          <div class="row"><button id="restart" class="btn primary">Restart</button><button id="shuffle" class="btn">Shuffle</button></div>
          <div class="row"><button id="addColor" class="btn small">Add Color Bomb</button><button id="useBomb" class="btn small">Use Bomb</button></div>
          <div class="row"><div class="pill" style="flex:1;text-align:center"><small>Combo</small><div id="combo">√ó1</div></div></div>
          <div class="row"><div class="progress" style="flex:1"><i id="progressBar"></i></div></div>
          <div class="row"><div class="levelBadge" id="levelBadge">Target: 800</div></div>
          <div class="row" style="margin-top:6px"><div style="flex:1;text-align:center"><small>Level Timer</small><div id="timer">‚Äî</div></div></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* CONFIG: change these if your image filenames are different */
const IMAGE_BASE = 'https://askirar275-wq.github.io/Candy/images/'; // <-- change if needed
const IMAGE_FILES = [
  'candy1.png','candy2.png','candy3.png','candy4.png','candy5.png',
  'candy6.png','candy7.png','candy8.png','candy9.png','candy10.png'
];
const BOMB_IMG = 'bomb.jpg'; // wrapped bomb image (if exists)

/* Core game variables */
const WIDTH = 8, HEIGHT = 8, SIZE = WIDTH*HEIGHT;
const grid = document.getElementById('grid'), particles = document.getElementById('particles');
let state = { nextId:1, board:[], score:0, moves:40, combo:1, level:1, target:800, inv:{color:0} };
let CELL = [], dragging=false, pointerId=null, startIndex=null, locked=false;
let levelTimer = null, levelTimeLeft = 0;

/* Load image urls (full) */
const SPRITES = IMAGE_FILES.map(fn => IMAGE_BASE + fn);
const BOMB_URL = IMAGE_BASE + BOMB_IMG;

/* helper: create tile object with src */
function makeTile(src){
  return { id: state.nextId++, src: src || SPRITES[Math.floor(Math.random()*SPRITES.length)], power:null, fallback: null };
}
function randTile(){ return makeTile(); }

/* fit tiles to area */
function fitTiles(){
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 4;
  const wrap = document.querySelector('.gridWrap').getBoundingClientRect();
  const availW = Math.max(200, wrap.width - 24), availH = Math.max(200, wrap.height - 24);
  const cW = Math.floor((availW - gap*(WIDTH-1)) / WIDTH);
  const cH = Math.floor((availH - gap*(HEIGHT-1)) / HEIGHT);
  let size = Math.max(36, Math.min(cW, cH));
  document.documentElement.style.setProperty('--tile', size + 'px');
}

/* build DOM cells once */
function buildGrid(){
  grid.innerHTML = '';
  CELL = [];
  grid.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const b = document.createElement('button');
    b.className = 'cell';
    b.dataset.index = i;
    const img = document.createElement('img');
    img.alt = 'candy';
    img.draggable = false;
    img.dataset.src = '';
    b.appendChild(img);
    b.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(b);
    CELL.push(b);
  }
}

/* safe image loader: sets img.src and fallback to emoji if load fails */
function setImageOrEmoji(imgEl, src, fallbackEmoji){
  if(!imgEl) return;
  if(!src) { // use emoji fallback
    imgEl.style.display = 'none';
    const span = imgEl.parentElement.querySelector('.tile-emoji');
    if(!span){ const s = document.createElement('span'); s.className='tile-emoji'; s.textContent = fallbackEmoji || 'üç¨'; imgEl.parentElement.appendChild(s); }
    return;
  }
  // remove any existing emoji fallback
  const span = imgEl.parentElement.querySelector('.tile-emoji');
  if(span) span.remove();
  imgEl.style.display = 'block';
  if(imgEl.dataset.src === src) return; // already set
  imgEl.dataset.src = src;
  imgEl.src = src;
  // if 404, fallback to emoji
  imgEl.onerror = ()=> {
    imgEl.dataset.src = '';
    imgEl.style.display = 'none';
    const s = document.createElement('span'); s.className='tile-emoji'; s.textContent = fallbackEmoji || 'üç¨';
    imgEl.parentElement.appendChild(s);
  };
}

/* render board (fast) - dropMap for fall animation */
function render(dropMap){
  for(let i=0;i<SIZE;i++) if(!state.board[i]) state.board[i] = randTile();
  for(let i=0;i<SIZE;i++){
    const t = state.board[i];
    const el = CELL[i];
    const img = el.querySelector('img');
    // desired src or fallback emoji
    const fallback = 'üç¨'; // used if image fails
    const src = t ? t.src : null;
    setImageOrEmoji(img, src, fallback);
    // mark power icon
    const pm = el.querySelector('.pm'); if(pm) pm.remove();
    if(t && t.power){
      const m = document.createElement('div'); m.className='pm'; m.style.position='absolute'; m.style.right='8px'; m.style.top='6px'; m.style.fontSize='12px';
      if(t.power.type==='striped') m.textContent = t.power.dir==='h' ? '‚Äî' : '‚îÇ';
      else if(t.power.type==='wrapped') m.textContent = 'üí£';
      else if(t.power.type==='color') m.textContent = '‚òÖ';
      el.appendChild(m);
    }
    el.classList.remove('pop');
    el.style.transition = '';
    el.style.transform = '';
    if(dropMap && t && dropMap[t.id]){
      el.style.transform = `translateY(${dropMap[t.id]})`;
      requestAnimationFrame(()=> requestAnimationFrame(()=> { el.style.transition = `transform var(--fall-dur) var(--ease)`; el.style.transform = 'translateY(0)'; }));
    }
  }
  updateHUD();
}

/* find matches by src (image) */
function findMatches(bd){
  const matches = [];
  try{
    for(let r=0;r<HEIGHT;r++){
      let run=[r*WIDTH];
      for(let c=1;c<WIDTH;c++){
        const p=r*WIDTH+c-1, i=r*WIDTH+c;
        if(bd[i] && bd[p] && bd[i].src === bd[p].src) run.push(i);
        else { if(run.length>=3) matches.push([...run]); run=[i]; }
      }
      if(run.length>=3) matches.push([...run]);
    }
    for(let c=0;c<WIDTH;c++){
      let run=[c];
      for(let r=1;r<HEIGHT;r++){
        const p=(r-1)*WIDTH+c, i=r*WIDTH+c;
        if(bd[i] && bd[p] && bd[i].src === bd[p].src) run.push(i);
        else { if(run.length>=3) matches.push([...run]); run=[i]; }
      }
      if(run.length>=3) matches.push([...run]);
    }
  }catch(e){ console.warn('findMatches', e); }
  return matches;
}

/* detect specials (color/striped/wrapped) */
function detectSpecials(matches){
  const assign = {};
  matches.forEach(run=>{
    if(run.length>=5){
      const idx = run[Math.floor(run.length/2)];
      assign[idx] = { type:'color' };
    } else if(run.length===4){
      const a = run[0], b = run[1];
      const isH = Math.floor(a/WIDTH) === Math.floor(b/WIDTH);
      const idx = run[Math.floor(run.length/2)];
      assign[idx] = { type:'striped', dir: isH ? 'h':'v' };
    }
  });
  return assign;
}

/* particle burst */
function burst(x,y,amount=12){
  const rect = grid.getBoundingClientRect();
  const ox = x - rect.left, oy = y - rect.top;
  const colors = ['#ff9ac8','#ffd28f','#a0e9ff','#ffd1f8','#c8ffb3'];
  for(let i=0;i<Math.min(24, amount); i++){
    const p = document.createElement('div');
    p.style.position='absolute'; p.style.left=ox+'px'; p.style.top=oy+'px';
    const s = 6 + Math.random()*10; p.style.width=p.style.height=s+'px';
    p.style.borderRadius='50%'; p.style.background = colors[Math.floor(Math.random()*colors.length)];
    p.style.pointerEvents='none'; particles.appendChild(p);
    const ang = Math.random()*Math.PI*2, dist = 20 + Math.random()*60, nx=Math.cos(ang)*dist, ny=Math.sin(ang)*dist;
    p.animate([{transform:'translate(-50%,-50%) scale(1)', opacity:1},{transform:`translate(-50%,-50%) translate(${nx}px,${ny}px) scale(.3)`, opacity:0}], {duration:500+Math.random()*400, easing:'cubic-bezier(.2,.8,.2,1)'});
    setTimeout(()=> p.remove(),1100);
  }
}

/* special activation (striped/wrapped/color) */
function activatePower(idx, otherSrc=null){
  const t = state.board[idx]; if(!t || !t.power) return;
  const p = t.power; const removed = new Set();
  if(p.type === 'striped'){
    if(p.dir === 'h'){ const r = Math.floor(idx/WIDTH); for(let c=0;c<WIDTH;c++) removed.add(r*WIDTH+c); }
    else { const c = idx%WIDTH; for(let r=0;r<HEIGHT;r++) removed.add(r*WIDTH + c); }
  } else if(p.type === 'wrapped'){
    const r0 = Math.floor(idx/WIDTH), c0 = idx%WIDTH;
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){ const nr = r0+dr, nc = c0+dc; if(nr>=0&&nr<HEIGHT&&nc>=0&&nc<WIDTH) removed.add(nr*WIDTH+nc); }
  } else if(p.type === 'color'){
    const targetSrc = otherSrc || t.src;
    for(let i=0;i<state.board.length;i++) if(state.board[i] && state.board[i].src === targetSrc) removed.add(i);
  }
  const arr = Array.from(removed);
  arr.forEach(i=>{ const el = CELL[i]; if(el) el.classList.add('pop'); state.board[i] = null; });
  state.score += arr.length * 15;
  setTimeout(()=> resolveChain(), 300);
}

/* resolveChain: match -> pop -> gravity -> refill -> place specials -> repeat */
function resolveChain(){
  if(locked) return; locked=true; state.combo = Math.max(1, state.combo);
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length === 0){ locked=false; updateHUD(); return; }
    const specialMap = detectSpecials(matches);
    const removeSet = new Set();
    matches.forEach(run => run.forEach(i => removeSet.add(i)));
    const indices = Array.from(removeSet).sort((a,b)=>a-b);
    const removedCount = indices.length;
    state.score += removedCount * 12 * state.combo;
    state.combo++;
    updateHUD();

    let cx=0, cy=0, cnt=0;
    indices.forEach(i=>{
      const el = CELL[i];
      if(el){ const rc = el.getBoundingClientRect(); cx += rc.left + rc.width/2; cy += rc.top + rc.height/2; cnt++; el.classList.add('pop'); }
      state.board[i] = null;
    });
    if(cnt) burst(cx/cnt, cy/cnt, Math.min(36, 6+cnt));

    setTimeout(()=>{
      // gravity & refill
      const cols = [];
      for(let c=0;c<WIDTH;c++){
        const col = [];
        for(let r=HEIGHT-1;r>=0;r--){ const idx = r*WIDTH+c; if(state.board[idx]) col.push(state.board[idx]); }
        cols.push(col);
      }
      const newBoard = new Array(SIZE).fill(null);
      const dropMap = {};
      const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
      const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
      for(let c=0;c<WIDTH;c++){
        const col = cols[c];
        while(col.length < HEIGHT) col.push(randTile());
        for(let r=HEIGHT-1,i=0; r>=0; r--, i++){
          const tile = col[i]; newBoard[r*WIDTH+c] = tile;
          if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
        }
      }
      // attach specials
      Object.keys(specialMap).forEach(k=>{
        const idx = Number(k);
        if(newBoard[idx]) newBoard[idx].power = specialMap[k];
        else { const pos = newBoard.findIndex(x=>x); if(pos>=0) newBoard[pos].power = specialMap[k]; }
      });

      state.board = newBoard;
      fitTiles(); render(dropMap);

      setTimeout(()=> setTimeout(step, 200), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fall-dur')) || 300);
    }, 320);
  })();
}

/* input handlers: drag to swap (with image tiles) */
function onPointerDown(e){
  if(locked) return;
  const el = e.currentTarget; el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true; pointerId = e.pointerId; startIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function cellFromPoint(x,y){
  try{ const el = document.elementFromPoint(x,y); return el ? el.closest('.cell') : null; } catch(e){ return null; }
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const cell = cellFromPoint(e.clientX, e.clientY);
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx) || idx === startIndex) return;
  // adjacency check
  const r1 = Math.floor(startIndex/WIDTH), c1 = startIndex%WIDTH, r2 = Math.floor(idx/WIDTH), c2 = idx%WIDTH;
  if(Math.abs(r1-r2)+Math.abs(c1-c2) !== 1) return;
  // swap
  swap(startIndex, idx);
  render();
  state.moves = Math.max(0, state.moves - 1);
  updateHUD();

  // check power interactions
  const A = state.board[idx], B = state.board[startIndex];
  if(A && A.power && A.power.type === 'color'){ activatePower(idx, B ? B.src : null); }
  else if(B && B.power && B.power.type === 'color'){ activatePower(startIndex, A ? A.src : null); }
  else if(A && A.power){ activatePower(idx); }
  else if(B && B.power){ activatePower(startIndex); }
  else {
    const m = findMatches(state.board);
    if(m.length>0) resolveChain();
    else setTimeout(()=>{ swap(startIndex, idx); render(); }, 260);
  }

  // stop dragging until next pointerdown
  dragging = false;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function onPointerUp(e){ dragging=false; pointerId=null; startIndex=null; document.removeEventListener('pointermove', onPointerMove); document.removeEventListener('pointerup', onPointerUp); }
function swap(i,j){ [state.board[i], state.board[j]] = [state.board[j], state.board[i]]; }

/* HUD / Level / Timer functions */
function updateHUD(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('moves').textContent = state.moves;
  document.getElementById('combo').textContent = `√ó${Math.max(1, state.combo-1)}`;
  document.getElementById('progressBar').style.width = Math.min(100, Math.round(state.score / state.target * 100)) + '%';
  document.getElementById('level').textContent = state.level;
  document.getElementById('levelBadge').textContent = `Target: ${state.target}`;
  if(state.score >= state.target) levelUp();
}

/* level up: increase level, new target, bonus moves, small animation */
function levelUp(){
  state.level++;
  state.target = Math.round(state.target * 1.4);
  state.moves += 6;
  state.combo = 1;
  // visual + particle + alert
  const card = document.getElementById('card');
  card.animate([{transform:'scale(1)'},{transform:'scale(1.02)'},{transform:'scale(1)'}],{duration:420,easing:'ease-out'});
  burst(window.innerWidth/2, window.innerHeight/2, 36);
  setTimeout(()=> alert(`‡§¨‡§ß‡§æ‡§à! Level ${state.level} ‡§™‡•Ç‡§∞‡§æ ‡§π‡•Å‡§Ü ‚Äî 6 extra moves ‡§Æ‡§ø‡§≤ ‡§ó‡§Ø‡•á`), 300);
  // increase difficulty slightly: reduce tile size for challenge (subtle)
  const cur = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 72;
  document.documentElement.style.setProperty('--tile', Math.max(40, Math.round(cur * 0.98)) + 'px');
  updateHUD();
  // reset timer for next level
  startLevelTimer();
}

/* Level timer: each level has time (base 60s reduced a bit per level) */
function startLevelTimer(){
  stopLevelTimer();
  const base = 60; // seconds
  const dec = Math.min(20, Math.floor(state.level * 2)); // difficulty shortens timer slightly
  levelTimeLeft = Math.max(15, base - dec);
  document.getElementById('timer').textContent = `${levelTimeLeft}s`;
  levelTimer = setInterval(()=>{
    levelTimeLeft--;
    document.getElementById('timer').textContent = `${levelTimeLeft}s`;
    if(levelTimeLeft <= 0){ // time up: penalty & stop
      stopLevelTimer();
      state.moves = Math.max(0, state.moves - 6);
      alert('‡§∏‡§Æ‡§Ø ‡§ñ‡§§‡•ç‡§Æ! Moves -6 ‡§π‡•Å‡§Ü‡•§');
      updateHUD();
      startLevelTimer();
    }
  }, 1000);
}
function stopLevelTimer(){ if(levelTimer) clearInterval(levelTimer); levelTimer = null; document.getElementById('timer').textContent = '‚Äî'; }

/* Controls */
document.getElementById('restart').addEventListener('click', ()=> { initBoard(); startLevelTimer(); });
document.getElementById('shuffle').addEventListener('click', ()=>{ state.board = state.board.sort(()=>Math.random()-0.5); render(); });
document.getElementById('addColor').addEventListener('click', ()=>{ state.inv.color++; alert('Color Bomb +1 added'); });
document.getElementById('useBomb').addEventListener('click', ()=>{
  if(locked) return;
  const valid = state.board.map((t,i)=> t? i:-1).filter(i=>i>=0);
  if(valid.length===0) return;
  const idx = valid[Math.floor(Math.random()*valid.length)];
  state.board[idx] = makeTile(BOMB_URL); state.board[idx].power = { type:'wrapped' };
  render();
  setTimeout(()=> activatePower(idx), 260);
});

/* init board (no immediate matches) */
function initBoard(){
  state.nextId = 1;
  state.board = new Array(SIZE).fill(null).map(()=>randTile());
  let tries = 0;
  while(findMatches(state.board).length>0 && tries++ < 900) state.board = new Array(SIZE).fill(null).map(()=>randTile());
  state.score = 0; state.moves = 40; state.combo = 1; state.level = 1; state.target = 800; state.inv.color = 0;
  fitTiles(); buildGrid(); render();
  startLevelTimer();
}

/* window resize */
let resizeTO; window.addEventListener('resize', ()=>{ clearTimeout(resizeTO); resizeTO = setTimeout(()=>{ fitTiles(); render(); }, 120); });

/* preload images (try fetch to see 404 quickly) */
(function preload(){
  SPRITES.forEach(u=>{ const i = new Image(); i.src = u; i.onerror = ()=> console.warn('Image failed to load:', u); });
  const ib = new Image(); ib.src = BOMB_URL; ib.onerror = ()=> console.warn('Bomb image failed to load:', BOMB_URL);
})();

/* start */
initBoard();
window._cm = { state };

/* debug helpers: open console and run */
window.showBoard = ()=> console.log(state.board.map(b=> b? (b.src.split('/').pop()) + (b.power? '['+b.power.type+']':'') : null));
</script>
</body>
</html>
