<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Candy Match ‚Äî Candy-Crush style specials</title>
<style>
:root{--cols:8;--rows:8;--gap:4px;--tile:64px;--accent:#ff4d9e;--pop-dur:260ms;--fall-dur:300ms}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
body{overflow:auto}
.stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
.card{width:100%;max-width:980px;padding:14px;border-radius:14px;background:#fff;box-shadow:0 18px 48px rgba(20,20,50,.06);display:flex;flex-direction:column;gap:12px;overflow:visible}
header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:28px}
.meta{font-size:13px;color:#666}
.hud{display:flex;gap:14px;align-items:center}
.hud .pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:10px 18px;border-radius:40px;box-shadow:0 10px 28px rgba(20,20,60,0.04);text-align:center;font-weight:800}
.content{display:flex;flex-direction:column;gap:8px;flex:1 1 auto;min-height:0}
.grid-area{flex:1 1 auto;display:flex;align-items:center;justify-content:center;min-height:0;padding:6px}
.grid-wrap{width:100%;max-width:860px;border-radius:12px;background:linear-gradient(180deg,#fff,#fff7fb);padding:10px;display:flex;align-items:center;justify-content:center;position:relative;box-shadow:inset 0 8px 30px rgba(250,240,250,0.4);max-height:calc(80vh);overflow:auto}
.grid{display:grid;gap:var(--gap);grid-template-columns:repeat(var(--cols), var(--tile));grid-auto-rows:var(--tile);justify-content:center;align-content:center;place-items:center;touch-action:none;user-select:none}
.cell{width:var(--tile);height:var(--tile);border-radius:14px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#fffefc);box-shadow:0 6px 14px rgba(10,10,30,0.06);cursor:grab;transition:transform .12s,opacity .12s;position:relative;border:1px solid rgba(0,0,0,0.04);overflow:visible;padding:0}
.cell img{ width:78%; height:78%; object-fit:contain; pointer-events:none; display:block; }
.cell .badge{ position:absolute; right:6px; top:6px; font-size:11px; background:rgba(255,255,255,0.9); padding:2px 6px; border-radius:10px; box-shadow:0 2px 5px rgba(0,0,0,0.06); }
.cell.pop{animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
@keyframes pop{0%{transform:scale(1);opacity:1}45%{transform:scale(1.4)}100%{transform:scale(0);opacity:0}}
.controls{flex:0 0 auto;display:flex;gap:12px;align-items:center;justify-content:center;padding:8px 6px;flex-wrap:wrap}
.btn{padding:12px 18px;border-radius:14px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
.footer{flex:0 0 86px;display:flex;align-items:center;justify-content:space-between;padding:10px 6px;gap:12px}
.progress{height:14px;width:240px;background:#eee;border-radius:999px;overflow:hidden}
.progress i{display:block;height:100%;width:0;background:linear-gradient(90deg,#ff9ac8,#ff6aa8);transition:width 320ms ease}
.note{font-size:12px;color:#888;padding:6px 8px;border-radius:8px;background:linear-gradient(180deg,#fff,#fff7fb)}
@media(max-width:720px){:root{--tile:52px;--gap:2px}.card{padding:10px}.grid-wrap{max-height:60vh}}
</style>
</head>
<body>
  <div class="stage">
    <div class="card" id="card">
      <header>
        <div class="brand">
          <div class="logo">üç≠</div>
          <div>
            <div style="font-weight:900;font-size:18px">Candy / Fruit Match</div>
            <div class="meta">GitHub images auto-detected + specials</div>
          </div>
        </div>
        <div class="hud">
          <div class="pill"><small>Level</small><div id="level">1</div></div>
          <div class="pill"><small>Score</small><div id="score">0</div></div>
          <div class="pill"><small>Moves</small><div id="moves">40</div></div>
        </div>
      </header>

      <div class="content">
        <div class="grid-area">
          <div id="gridWrap" class="grid-wrap">
            <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
          </div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap">
          <button id="restart" class="btn primary">Restart</button>
          <button id="shuffle" class="btn">Shuffle</button>
          <button id="placeBomb" class="btn">Place Bomb</button>
        </div>

      </div>

      <div class="footer">
        <div class="note">Images loaded from <span id="imgCount">0</span> files</div>
        <div style="display:flex;align-items:center;gap:12px">
          <div id="comboText" style="font-weight:900;color:var(--accent)">Combo √ó1</div>
          <div class="progress" aria-hidden><i id="progressBar"></i></div>
        </div>
      </div>
    </div>
  </div>

<script>
/* Candy Crush like specials added to previous game
   - Striped (4 in a row) -> clears row/col
   - Wrapped (T/L) -> clears 3x3
   - Color bomb (5 in line) -> clears all of that src
   - Combos between specials simplified
*/

const WIDTH = 8, HEIGHT = 8, SIZE = WIDTH*HEIGHT;
const IMAGE_BASE = 'images/';
const CANDIDATES = ['candy1.png','candy2.png','candy3.png','candy4.png','candy5.png','candy6.png','candy7.png','candy8.png','candy9.png','candy10.png','donut.png','bomb.jpg'];

const grid = document.getElementById('grid');
const imgCountEl = document.getElementById('imgCount');

let state = { nextId:1, board:[], score:0, moves:40, combo:1 };
let locked=false, dragging=false, pointerId=null, lastIndex=null;
let CELL_ELEMENTS = [], pool=[];

/* try load */
function tryLoad(url){ return new Promise(res=>{ const i=new Image(); i.onload=()=>res({ok:true,url}); i.onerror=()=>res({ok:false,url}); i.src=url; });}
async function detectImages(){
  const res = await Promise.all(CANDIDATES.map(n=>tryLoad(IMAGE_BASE+n)));
  pool = res.filter(r=>r.ok).map(r=>r.url);
  imgCountEl.textContent = pool.length;
  if(pool.length===0) pool = ['data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="100%" height="100%" fill="%23eee"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="%23222" font-size="10">üç≠</text></svg>'];
  return pool;
}

/* layout fit */
function fitTiles(){
  try{
    const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 4;
    const cardRect = document.getElementById('card').getBoundingClientRect();
    const headerH = document.querySelector('header').getBoundingClientRect().height;
    const controlsH = 60;
    const footerH = document.querySelector('.footer').getBoundingClientRect().height;
    const padTop = parseFloat(getComputedStyle(document.getElementById('card')).paddingTop)||0;
    const padBottom = parseFloat(getComputedStyle(document.getElementById('card')).paddingBottom)||0;
    const availH = cardRect.height - headerH - controlsH - footerH - padTop - padBottom - 8;
    const availW = Math.min(grid.parentElement.getBoundingClientRect().width - 8, cardRect.width - 28);
    const candidateH = Math.floor((availH - gap*(HEIGHT-1))/HEIGHT);
    const candidateW = Math.floor((availW - gap*(WIDTH-1))/WIDTH);
    let base = Math.max(18, Math.min(candidateH,candidateW));
    let desired = Math.floor(base*1.05);
    if(desired<18) desired=18;
    document.documentElement.style.setProperty('--tile', desired+'px');
  }catch(e){ console.warn('fitTiles',e); }
}

/* create cells */
function createCellsOnce(){
  grid.innerHTML=''; CELL_ELEMENTS=[];
  grid.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const el=document.createElement('button'); el.className='cell'; el.dataset.index=i;
    const img=document.createElement('img'); img.alt='candy'; img.draggable=false; img.dataset.src='';
    el.appendChild(img);
    el.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(el);
    CELL_ELEMENTS.push({button:el, img});
  }
}

/* helpers */
function makeTile(src){ return { id: state.nextId++, src: src || pool[Math.floor(Math.random()*pool.length)], power:null }; }
function randTile(){ return makeTile(); }

/* render (defensive) */
function renderFast(dropMap){
  try{
    if(!CELL_ELEMENTS || CELL_ELEMENTS.length!==SIZE) createCellsOnce();
    for(let i=0;i<SIZE;i++) if(!state.board[i]) state.board[i]=randTile();
    for(let i=0;i<SIZE;i++){
      const tile = state.board[i];
      const entry = CELL_ELEMENTS[i];
      if(!entry) continue;
      const {button,img} = entry;
      // remove stray text
      button.childNodes.forEach(n=>{ if(n.nodeType===3) n.remove(); });
      const desired = (tile && tile.src)?tile.src:'';
      if(img.dataset.src!==desired){ img.dataset.src = desired; img.src = desired; }
      // badge for special
      let badge = button.querySelector('.badge');
      if(tile && tile.power){
        if(!badge){ badge = document.createElement('div'); badge.className='badge'; button.appendChild(badge); }
        badge.textContent = tile.power.type==='color' ? '‚òÖ' : (tile.power.type==='striped' ? (tile.power.dir==='h'?'‚ïê':'‚ïë') : '‚óç');
      } else { if(badge) badge.remove(); }
      button.style.transition=''; button.style.transform='';
      if(dropMap && tile && dropMap[tile.id]){ button.style.transform = `translateY(${dropMap[tile.id]})`; requestAnimationFrame(()=>requestAnimationFrame(()=>{ button.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`; button.style.transform='translateY(0)'; })); }
      button.classList.remove('pop');
    }
    updateHUD();
  }catch(e){ console.error('renderFast',e); }
}

/* match detection with shape recognition for T/L */
function findMatchesWithShapes(bd){
  const runs = [];
  const horizontal = [];
  const vertical = [];
  // horizontal runs
  for(let r=0;r<HEIGHT;r++){
    let run=[r*WIDTH];
    for(let c=1;c<WIDTH;c++){
      const p=r*WIDTH+c-1,i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].src===bd[p].src) run.push(i);
      else { if(run.length>=3) horizontal.push([...run]); run=[i]; }
    }
    if(run.length>=3) horizontal.push([...run]);
  }
  // vertical runs
  for(let c=0;c<WIDTH;c++){
    let run=[c];
    for(let r=1;r<HEIGHT;r++){
      const p=(r-1)*WIDTH+c,i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].src===bd[p].src) run.push(i);
      else { if(run.length>=3) vertical.push([...run]); run=[i]; }
    }
    if(run.length>=3) vertical.push([...run]);
  }
  // collect runs
  runs.push(...horizontal, ...vertical);

  // detect T/L shapes: if any index appears in both a horizontal and vertical run -> T/L -> treat as wrapped
  const wrappedCenters = new Set();
  const horizMap = new Map();
  horizontal.forEach(run => run.forEach(i => horizMap.set(i, (horizMap.get(i)||0)+1)));
  const vertMap = new Map();
  vertical.forEach(run => run.forEach(i => vertMap.set(i, (vertMap.get(i)||0)+1)));
  horizMap.forEach((v,k)=>{ if(vertMap.has(k)) wrappedCenters.add(k); });

  // merge overlapping runs and wrapped centers into final matches array
  const final = [];
  const used = new Set();
  runs.forEach(run=>{
    run.forEach(i=> used.add(i));
  });
  // add runs
  runs.forEach(run=> final.push([...run]));
  // add wrapped centers as separate matches (we will convert them into wrapped special)
  wrappedCenters.forEach(center => final.push([center])); // single center flagged later
  return {matches: final, wrappedCenters: Array.from(wrappedCenters)};
}

/* create special from match info */
function assignSpecials(matches, wrappedCenters, bd){
  const specialMap = {};
  // for each run, if length==4 -> striped; length>=5 -> color bomb; length==3 -> none
  matches.forEach(run=>{
    if(run.length>=5){
      const idx = run[Math.floor(run.length/2)];
      specialMap[idx] = {type:'color'};
    } else if(run.length===4){
      const idx = run[Math.floor(run.length/2)];
      // determine orientation: if run indexes differ by 1 -> horizontal, else vertical
      const a=run[0], b=run[1];
      const dir = (Math.abs(a-b)===1)?'h':'v';
      specialMap[idx] = {type:'striped', dir};
    }
  });
  // wrapped centers produce wrapped specials
  wrappedCenters.forEach(center => { specialMap[center] = {type:'wrapped'}; });
  return specialMap;
}

/* detect matches wrapper */
function detectMatchesAndSpecials(){
  const {matches, wrappedCenters} = findMatchesWithShapes(state.board);
  const specialCandidates = assignSpecials(matches, wrappedCenters, state.board);
  return {matches, specialCandidates};
}

/* apply special effects when resolving */
function triggerSpecialAt(idx, removedSet){
  const tile = state.board[idx];
  if(!tile || !tile.power) return;
  const p = tile.power;
  if(p.type==='striped'){
    // clear row or column depending on dir
    const r = Math.floor(idx/WIDTH), c = idx%WIDTH;
    if(p.dir==='h'){
      for(let cc=0; cc<WIDTH; cc++) removedSet.add(r*WIDTH+cc);
    } else {
      for(let rr=0; rr<HEIGHT; rr++) removedSet.add(rr*WIDTH+c);
    }
  } else if(p.type==='wrapped'){
    const r = Math.floor(idx/WIDTH), c = idx%WIDTH;
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      const nr=r+dr,nc=c+dc;
      if(nr>=0&&nr<HEIGHT&&nc>=0&&nc<WIDTH) removedSet.add(nr*WIDTH+nc);
    }
  } else if(p.type==='color'){
    // remove all tiles with same src as this tile
    const targetSrc = tile.src;
    for(let i=0;i<SIZE;i++) if(state.board[i] && state.board[i].src===targetSrc) removedSet.add(i);
  }
}

/* resolve chain including specials and combos */
function resolveChain(){
  if(locked) return;
  locked=true; state.combo=1;
  (function step(){
    const {matches, specialCandidates} = detectMatchesAndSpecials();
    // flatten matches -> unique indexes
    const removeSet = new Set();
    matches.forEach(run=> run.forEach(i=> removeSet.add(i)));
    // apply specials creation (we will place special at specialCandidates indexes AFTER removal)
    const specialsToCreate = specialCandidates; // map idx -> special descriptor
    // Now, if no matches -> stop
    if(removeSet.size===0){ locked=false; updateHUD(); return; }
    // Before removing, handle if any of removed tiles have existing special power -> they should trigger effects (chain)
    const toProcessSpecials = [];
    Array.from(removeSet).forEach(i=>{
      if(state.board[i] && state.board[i].power) toProcessSpecials.push(i);
    });
    // collect expanded removal due to special triggers
    const expanded = new Set(removeSet);
    toProcessSpecials.forEach(idx => triggerSpecialAt(idx, expanded));

    // convert expanded set to array
    const removeIdx = Array.from(expanded).sort((a,b)=>a-b);
    const removedCount = removeIdx.length;
    state.score += removedCount * 12 * state.combo;
    state.combo++;
    updateHUD();

    // animate pop
    let cx=0,cy=0,cnt=0;
    removeIdx.forEach(i=>{
      const el = CELL_ELEMENTS[i] && CELL_ELEMENTS[i].button;
      if(el){ const rc = el.getBoundingClientRect(); cx+=rc.left+rc.width/2; cy+=rc.top+rc.height/2; cnt++; el.classList.add('pop'); }
      state.board[i] = null;
    });
    if(cnt>0) burst(cx/cnt, cy/cnt, Math.min(10, 4+cnt));

    // after pop, create specials at intended positions (if any) on the top-most surviving tile of that column/position
    setTimeout(()=>{
      try{
        // gravity & refill
        const cols = [];
        for(let c=0;c<WIDTH;c++){
          const col=[];
          for(let r=HEIGHT-1;r>=0;r--){
            const idx = r*WIDTH+c;
            if(state.board[idx]) col.push(state.board[idx]);
          }
          cols.push(col);
        }
        const newBoard = new Array(SIZE).fill(null);
        const dropMap = {};
        const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
        const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
        for(let c=0;c<WIDTH;c++){
          const col = cols[c];
          while(col.length < HEIGHT) col.push(randTile());
          for(let r=HEIGHT-1,i=0;r>=0;r--,i++){
            const tile = col[i];
            newBoard[r*WIDTH+c] = tile;
            if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
          }
        }
        // place specials that were created by matches: if target index now occupied, set power accordingly
        Object.keys(specialsToCreate).forEach(k=>{
          const intended = Number(k);
          const spec = specialsToCreate[k];
          // if color special - set type='color', if striped - direction same as spec.dir, wrapped -> wrapped
          if(newBoard[intended]){
            newBoard[intended].power = {...spec};
            // ensure color special has explicit type 'color'
            if(spec.type==='color') newBoard[intended].power.type='color';
          } else {
            // fallback: find nearest tile to set special
            const pos = newBoard.findIndex(x=>x);
            if(pos>=0) newBoard[pos].power = {...spec};
          }
        });

        state.board = newBoard;
        fitTiles(); renderFast(dropMap);
      }catch(e){ console.error('gravity/refill error', e); }
      setTimeout(()=> setTimeout(step, 220), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fall-dur')) || 320);
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 300);
  })();
}

/* input handling (drag swap) */
function onPointerDown(e){
  if(locked) return;
  try{
    const el = e.currentTarget; el.setPointerCapture && el.setPointerCapture(e.pointerId);
    dragging=true; pointerId=e.pointerId; lastIndex = Number(el.dataset.index);
    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);
  }catch(err){ console.warn('onPointerDown error', err); }
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  try{
    const target = document.elementFromPoint(e.clientX, e.clientY);
    if(!target) return;
    const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
    if(!cell) return;
    const idx = Number(cell.dataset.index);
    if(Number.isNaN(idx)) return;
    if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
      // swap and check matches / handle special swap combos
      swap(lastIndex, idx);
      renderFast();
      state.moves = Math.max(0, state.moves-1);
      updateHUD();
      // if either swapped tile is a color-bomb AND the other has a src -> trigger color-bomb effect
      const a = state.board[idx], b = state.board[lastIndex];
      if(a && a.power && a.power.type==='color' && b){
        // color bomb swapped with b -> remove all with b.src
        const removed = new Set();
        for(let i=0;i<SIZE;i++) if(state.board[i] && state.board[i].src === b.src) removed.add(i);
        removed.forEach(i=> state.board[i]=null);
        resolveChain();
      } else if(b && b.power && b.power.type==='color' && a){
        const removed = new Set();
        for(let i=0;i<SIZE;i++) if(state.board[i] && state.board[i].src === a.src) removed.add(i);
        removed.forEach(i=> state.board[i]=null);
        resolveChain();
      } else {
        const matches = findMatches(state.board);
        if(matches.length>0) resolveChain();
        else setTimeout(()=>{ swap(lastIndex, idx); renderFast(); }, 220);
      }
      lastIndex = idx;
    }
  }catch(err){ console.warn('onPointerMove error', err); }
}
function onPointerUp(e){
  dragging=false; pointerId=null; lastIndex=null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){ if(a==null||b==null) return false; const r1=Math.floor(a/WIDTH), c1=a%WIDTH, r2=Math.floor(b/WIDTH), c2=b%WIDTH; return Math.abs(r1-r2)+Math.abs(c1-c2)===1; }
function swap(i,j){ [state.board[i], state.board[j]] = [state.board[j], state.board[i]]; }

/* Place bomb button (for testing) */
document.getElementById('placeBomb').addEventListener('click', ()=>{
  if(locked) return;
  const valid = state.board.map((t,i)=> t ? i : -1).filter(i=> i>=0);
  if(valid.length===0) return;
  const idx = valid[Math.floor(Math.random()*valid.length)];
  state.board[idx] = makeTile(IMAGE_BASE + 'bomb.jpg');
  state.board[idx].power = {type:'wrapped'}; // bomb acts like wrapped explosion here
  renderFast();
  setTimeout(()=> resolveChain(), 220);
});

/* HUD */
function updateHUD(){
  try{
    document.getElementById('score').textContent = state.score;
    document.getElementById('moves').textContent = state.moves;
    document.getElementById('comboText').textContent = `Combo √ó${Math.max(1, state.combo-1)}`;
    document.getElementById('progressBar').style.width = Math.min(100, Math.round(state.score/1000*100)) + '%';
  }catch(err){ console.warn('updateHUD error', err); }
}

/* controls */
document.getElementById('restart').addEventListener('click', ()=> initBoardFast());
document.getElementById('shuffle').addEventListener('click', ()=>{ state.board.sort(()=>Math.random()-0.5); renderFast(); });

/* init board (no initial matches) */
function initBoardFast(){
  state.nextId=1;
  state.board = new Array(SIZE).fill(null).map(()=>randTile());
  let tries=0;
  while((function(){ // ensure no immediate matches
    const {matches} = findMatchesWithShapes(state.board);
    return matches.length>0;
  })() && tries++<800){
    state.board = new Array(SIZE).fill(null).map(()=>randTile());
  }
  state.score=0; state.moves=40; state.combo=1;
  fitTiles(); renderFast();
}

/* resize */
let resizeTO;
window.addEventListener('resize', ()=>{ clearTimeout(resizeTO); resizeTO=setTimeout(()=>{ fitTiles(); renderFast(); },120); });

/* preload images, then start */
(async function start(){
  await detectImages();
  pool.forEach(u=>{ const i=new Image(); i.src=u; });
  createCellsOnce();
  initBoardFast();
  updateHUD();
  window._cm = { state, renderFast, initBoardFast, fitTiles, pool };
})();

</script>
</body>
</html>
