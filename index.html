<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Candy Pop ‚Äî Cartoon Edition</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üç≠</text></svg>">
<style>
  /* Cartoon UI */
  :root{
    --cols:8; --rows:8;
    --gap:6px; --tile:64px;
    --accent1:#ff6bd6; --accent2:#ffcf6b;
    --bg1:#fffbff; --bg2:#f2f8ff;
    --card-radius:20px;
    --shadow: 0 18px 48px rgba(20,20,50,.08);
    --pop-dur:300ms; --fall-dur:320ms;
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family: 'Poppins', Inter, system-ui, Arial; background:linear-gradient(180deg,var(--bg1),var(--bg2)); color:#222; -webkit-font-smoothing:antialiased}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}

  /* Card */
  .app{
    width:100%; max-width:980px; border-radius:var(--card-radius); padding:18px;
    background: linear-gradient(180deg,#fff,#fffaff);
    box-shadow:var(--shadow);
    display:flex; gap:14px; flex-direction:column; align-items:stretch;
  }

  /* Home screen overlay */
  .home{
    display:flex; gap:18px; align-items:center; justify-content:space-between; padding:14px; border-radius:14px;
    background: linear-gradient(90deg,#fff0f7,#f8fff7); border: 4px solid rgba(255,150,200,0.06);
  }
  .logo{
    display:flex; gap:12px; align-items:center;
  }
  .logo .icon{
    width:72px;height:72px;border-radius:16px;background:linear-gradient(135deg,#fff,#ffeef8);
    display:flex;align-items:center;justify-content:center;font-size:36px;box-shadow:0 10px 30px rgba(255,120,190,.12)
  }
  .logo h1{margin:0;font-size:20px}
  .home .actions{display:flex;gap:12px;align-items:center}
  .btn{padding:12px 18px;border-radius:14px;border:0;background:#fff;font-weight:800;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
  .btn.primary{background:linear-gradient(90deg,var(--accent1),#ff9ac8);color:#fff}

  /* Game area */
  .layout{display:flex;gap:12px;align-items:flex-start;flex-direction:column}
  .hud{display:flex;gap:10px;align-items:center}
  .pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:8px 12px;border-radius:999px; font-weight:800;box-shadow:0 10px 22px rgba(20,20,60,0.04)}

  .board-wrap{display:flex;flex-direction:column;gap:10px;align-items:center}
  .board-area{
    background:linear-gradient(180deg,#fff7ff,#fff); padding:12px; border-radius:18px; box-shadow:inset 0 10px 30px rgba(250,240,250,0.4);
    width:100%; max-width:820px; display:flex; align-items:center; justify-content:center;
  }

  .grid{
    display:grid; gap:var(--gap); grid-template-columns: repeat(var(--cols), var(--tile)); grid-auto-rows: var(--tile);
    touch-action:none; user-select:none; transform-origin:center;
  }

  .cell{
    width:var(--tile); height:var(--tile); border-radius:14px; display:flex;align-items:center;justify-content:center;
    background: linear-gradient(180deg,#fff,#fff7f9); box-shadow: 0 10px 30px rgba(240,200,230,0.06); position:relative; overflow:visible; border:2px solid rgba(255,255,255,0.5);
    cursor:grab; transition: transform .12s ease, opacity .12s;
  }
  .cell.hidden{ visibility:hidden; }
  .cell img{ width:84%; height:84%; object-fit:contain; pointer-events:none; display:block; border-radius:10px; }

  /* pop */
  .cell.pop{animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
  @keyframes pop{0%{transform:scale(1);opacity:1}50%{transform:scale(1.4)}100%{transform:scale(0);opacity:0}}

  /* controls */
  .controls{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
  .shop-btn{background:linear-gradient(90deg,#a6e1ff,#8ac6ff); color:#fff; font-weight:900;padding:10px 14px;border-radius:12px;border:0; cursor:pointer}
  .footer{display:flex;justify-content:space-between; align-items:center; gap:10px}

  /* modal */
  .modal-bg{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(10,10,20,0.4);display:none;align-items:center;justify-content:center;z-index:999}
  .modal{width:94%;max-width:720px;background:#fff;border-radius:16px;padding:14px;box-shadow:0 30px 80px rgba(10,10,30,0.25);}

  /* cartoon accent */
  .cartoon-bubble{padding:8px 12px;border-radius:999px;background:linear-gradient(90deg,#fff6fb,#fff); box-shadow:0 8px 24px rgba(255,120,190,0.08); font-weight:800}

  @media(max-width:720px){
    :root{ --tile:52px; --gap:4px }
    .logo h1{font-size:16px}
    .logo .icon{width:56px;height:56px;font-size:28px}
    .grid{transform:scale(.95)}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="app" id="app">
      <!-- HOME BAR -->
      <div class="home">
        <div class="logo">
          <div class="icon">üç≠</div>
          <div>
            <h1>Candy Pop ‚Äî Cartoon</h1>
            <div style="font-size:12px;color:#666">Match, pop & combo ‚Äî mobile friendly</div>
          </div>
        </div>
        <div class="actions">
          <button id="openShop" class="btn">Shop</button>
          <button id="goHome" class="btn">Home</button>
          <button id="startBtn" class="btn primary">Start</button>
        </div>
      </div>

      <!-- LAYOUT -->
      <div class="layout">
        <div class="hud">
          <div class="pill">Score <div id="score" style="font-size:16px">0</div></div>
          <div class="pill">Moves <div id="moves" style="font-size:16px">40</div></div>
          <div class="pill">Level <div id="level" style="font-size:16px">1</div></div>
          <div class="cartoon-bubble" id="comboText">Combo √ó1</div>
        </div>

        <div class="board-wrap">
          <div class="board-area">
            <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
          </div>

          <div class="controls" style="margin-top:8px">
            <button id="restart" class="btn primary">Restart</button>
            <button id="shuffle" class="btn">Shuffle</button>
            <button id="useBomb" class="btn">Use Bomb</button>
          </div>
        </div>
      </div>

      <div class="footer">
        <div class="note">Images loaded from <span id="imgCount">0</span></div>
        <div style="display:flex;gap:8px;align-items:center">
          <div class="cartoon-bubble">Cartoon Mode</div>
        </div>
      </div>
    </div>
  </div>

  <!-- SHOP MODAL -->
  <div id="modalBg" class="modal-bg" aria-hidden="true">
    <div class="modal">
      <h3>Shop</h3>
      <div id="shopItems" style="display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:10px"></div>
      <div style="display:flex;justify-content:flex-end;margin-top:12px">
        <button id="closeShop" class="btn">Close</button>
      </div>
    </div>
  </div>

<script>
/* ====== CONFIG ====== */
const IMAGE_BASE = 'images/';
const IMAGE_LIST = [
  'candy1.png','candy2.png','candy3.png','candy4.png','candy5.png',
  'candy6.png','candy7.png','candy8.png','candy9.png','candy10.png'
];
const BOMB_IMG = 'bomb.png';

/* ====== GRID SETTINGS ====== */
const COLS = 8, ROWS = 8, SIZE = COLS * ROWS;

/* ====== DOM ====== */
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const comboText = document.getElementById('comboText');
const imgCountEl = document.getElementById('imgCount');
const modalBg = document.getElementById('modalBg');
const shopItemsEl = document.getElementById('shopItems');

/* ====== STATE ====== */
let pool = []; // available absolute URLs (detected)
let state = { nextId:1, board: new Array(SIZE).fill(null), score:0, moves:40, combo:1 };
let CELL = []; // DOM refs
let dragging=false, pointerId=null, startIndex=null, locked=false;

/* ====== UTIL: preload image (detect) ====== */
function tryLoad(url){
  return new Promise(res=>{
    const img = new Image();
    img.onload = ()=> res({ok:true,url});
    img.onerror = ()=> res({ok:false,url});
    img.src = url;
  });
}
async function detectImages(){
  const results = await Promise.all(IMAGE_LIST.map(n => tryLoad(IMAGE_BASE + n)));
  pool = results.filter(r=>r.ok).map(r=>r.url);
  if(pool.length === 0) {
    // fallback to simple colored emoji images (svg data URIs)
    pool = IMAGE_LIST.slice(0,6).map((_,i)=>`data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256'><rect width='100%' height='100%' fill='%23${(i*2+2).toString(16)}'></rect><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' font-size='80'>üç≠</text></svg>`);
  }
  // bomb - check
  tryLoad(IMAGE_BASE + BOMB_IMG).then(r => {
    if(r.ok) pool.bomb = r.url;
    else pool.bomb = null;
  });
  imgCountEl.textContent = pool.length;
}

/* ====== GRID: create cells once ====== */
function createCells(){
  gridEl.innerHTML = '';
  CELL = [];
  gridEl.style.setProperty('--cols', COLS);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    const img = document.createElement('img');
    img.alt = 'candy';
    img.draggable = false;
    btn.appendChild(img);
    btn.addEventListener('pointerdown', onDown);
    gridEl.appendChild(btn);
    CELL.push({btn,img});
  }
}

/* ====== TILES ====== */
function makeTile(src){
  return { id: state.nextId++, src: src || pool[Math.floor(Math.random()*pool.length)], power:null };
}
function fillInitialBoard(){
  for(let i=0;i<SIZE;i++) state.board[i] = makeTile();
  // avoid immediate matches
  let tries=0;
  while(findMatches(state.board).length > 0 && tries++ < 800){
    for(let i=0;i<SIZE;i++) state.board[i] = makeTile();
  }
}

/* ====== RENDER (no random creation here) ====== */
function render(dropMap){
  for(let i=0;i<SIZE;i++){
    const tile = state.board[i];
    const {btn,img} = CELL[i];
    // clear stray text
    btn.childNodes.forEach(n=>{ if(n.nodeType===3) n.remove(); });
    if(tile){
      if(img.dataset.src !== tile.src){
        img.dataset.src = tile.src;
        img.src = tile.src;
      }
      btn.style.visibility = 'visible';
    } else {
      img.dataset.src = '';
      img.src = '';
      btn.style.visibility = 'hidden';
    }
    btn.style.transition = '';
    btn.style.transform = '';
    if(dropMap && tile && dropMap[tile.id]){
      btn.style.transform = `translateY(${dropMap[tile.id]})`;
      requestAnimationFrame(()=> requestAnimationFrame(()=> {
        btn.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`;
        btn.style.transform = 'translateY(0)';
      }));
    }
    btn.classList.remove('pop');
  }
  updateHUD();
}

/* ====== MATCH FINDING (by src) ====== */
function findMatches(bd){
  const matches = [];
  // horizontal
  for(let r=0;r<ROWS;r++){
    let run=[r*COLS];
    for(let c=1;c<COLS;c++){
      const p=r*COLS+c-1, i=r*COLS+c;
      if(bd[i] && bd[p] && bd[i].src === bd[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let run=[c];
    for(let r=1;r<ROWS;r++){
      const p=(r-1)*COLS+c, i=r*COLS+c;
      if(bd[i] && bd[p] && bd[i].src === bd[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* ====== SPECIAL detection (simplified) ====== */
function detectSpecials(matches){
  const assign = {};
  matches.forEach(run=>{
    if(run.length>=5){
      const idx = run[Math.floor(run.length/2)]; assign[idx] = {type:'bomb'};
    } else if(run.length===4){
      const idx = run[Math.floor(run.length/2)]; assign[idx] = {type:'bomb'};
    }
  });
  return assign;
}

/* ====== POP & GRAVITY & REFILL ====== */
function burst(cx,cy,amt=8){
  amt = Math.min(8,amt);
  const rect = gridEl.getBoundingClientRect();
  const ox = cx - rect.left, oy = cy - rect.top;
  for(let i=0;i<amt;i++){
    const p = document.createElement('div');
    p.style.position='absolute'; p.style.left = ox+'px'; p.style.top = oy+'px';
    const s = 6 + Math.random()*8; p.style.width = p.style.height = s + 'px';
    p.style.borderRadius='50%'; p.style.background = `rgba(255,90,140,${0.35+Math.random()*0.5})`; p.style.pointerEvents='none';
    gridEl.parentElement.appendChild(p);
    const a = Math.random()*Math.PI*2, d = 18 + Math.random()*40;
    const nx=Math.cos(a)*d, ny=Math.sin(a)*d;
    p.animate([{transform:'translate(-50%,-50%) scale(1)',opacity:1},{transform:`translate(-50%,-50%) translate(${nx}px,${ny}px) scale(.3)`,opacity:0}],{duration:420+Math.random()*260, easing:'cubic-bezier(.2,.8,.2,1)'});
    setTimeout(()=>p.remove(),1000);
  }
}

function resolveChain(){
  if(locked) return;
  locked = true; state.combo = 1;
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length === 0){ locked = false; updateHUD(); return; }
    const specialMap = detectSpecials(matches);
    const removedSet = new Set();
    matches.forEach(run=> run.forEach(i=> removedSet.add(i)));
    const removedIdx = Array.from(removedSet).sort((a,b)=>a-b);
    const removedCount = removedIdx.length;
    state.score += removedCount * 12 * state.combo; state.combo++; updateHUD();

    // animate pop & remove
    let cx=0, cy=0, cnt=0;
    removedIdx.forEach(i=>{
      const el = CELL[i].btn;
      if(el){
        const rc = el.getBoundingClientRect();
        cx += rc.left + rc.width/2; cy += rc.top + rc.height/2; cnt++;
        el.classList.add('pop');
      }
      state.board[i] = null;
    });
    if(cnt>0) burst(cx/cnt, cy/cnt, Math.min(10, 4+cnt));

    // gravity + refill (ONLY create new tiles here)
    setTimeout(()=>{
      try{
        const cols = [];
        for(let c=0;c<COLS;c++){
          const col=[];
          for(let r=ROWS-1;r>=0;r--){
            const idx = r*COLS + c;
            if(state.board[idx]) col.push(state.board[idx]);
          }
          cols.push(col);
        }
        const newBoard = new Array(SIZE).fill(null);
        const dropMap = {};
        const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
        const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
        for(let c=0;c<COLS;c++){
          const col = cols[c];
          while(col.length < ROWS) col.push(makeTile()); // NEW tiles created here ONLY
          for(let r=ROWS-1,i=0;r>=0;r--,i++){
            const tile = col[i];
            newBoard[r*COLS + c] = tile;
            if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
          }
        }
        // place special images for specialMap
        Object.keys(specialMap).forEach(k => {
          const idx = Number(k);
          if(newBoard[idx]) newBoard[idx].src = IMAGE_BASE + BOMB_IMG;
          else { const pos = newBoard.findIndex(x=>x); if(pos>=0) newBoard[pos].src = IMAGE_BASE + BOMB_IMG; }
        });

        state.board = newBoard;
        fitTiles(); render(dropMap);
      }catch(e){ console.error('gravity/refill err', e); }
      setTimeout(()=> setTimeout(step, 220), 320);
    }, 300);
  })();
}

/* ====== SWAP INPUT (pointer drag) ====== */
function onDown(e){
  if(locked) return;
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true; pointerId = e.pointerId; startIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onMove);
  document.addEventListener('pointerup', onUp);
}
function onMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(startIndex, idx) && idx !== startIndex){
    // swap tile objects (no new tile creation here)
    swapTiles(startIndex, idx);
    render();
    state.moves = Math.max(0, state.moves-1);
    updateHUD();
    const matches = findMatches(state.board);
    if(matches.length > 0) resolveChain();
    else setTimeout(()=>{ swapTiles(startIndex, idx); render(); }, 260);
    // set next start to idx so consecutive drags allow chain swaps
    startIndex = idx;
  }
}
function onUp(e){
  dragging=false; pointerId=null; startIndex=null;
  document.removeEventListener('pointermove', onMove);
  document.removeEventListener('pointerup', onUp);
}
function isAdjacent(a,b){
  if(a==null || b==null) return false;
  const r1 = Math.floor(a/COLS), c1 = a%COLS, r2 = Math.floor(b/COLS), c2 = b%COLS;
  return Math.abs(r1-r2) + Math.abs(c1-c2) === 1;
}
function swapTiles(i,j){ [state.board[i], state.board[j]] = [state.board[j], state.board[i]]; }

/* ====== UI: controls ====== */
document.getElementById('startBtn').addEventListener('click', ()=> {
  showHome(false);
  // start (if not already)
  render();
});
document.getElementById('goHome').addEventListener('click', ()=> showHome(true));
function showHome(yes){
  const app = document.getElementById('app');
  if(yes) app.style.opacity = '0.6', app.style.filter = 'blur(4px)';
  else app.style.opacity = '1', app.style.filter = 'none';
}

/* shop modal */
document.getElementById('openShop').addEventListener('click', ()=> {
  buildShop();
  modalBg.style.display = 'flex';
  modalBg.setAttribute('aria-hidden','false');
});
document.getElementById('closeShop').addEventListener('click', ()=> {
  modalBg.style.display = 'none';
  modalBg.setAttribute('aria-hidden','true');
});
function buildShop(){
  shopItemsEl.innerHTML = '';
  const items = [
    {id:'bomb',name:'Bomb',price:220,emoji:'üí£'},
    {id:'shuffle',name:'Shuffle',price:120,emoji:'üîÄ'},
    {id:'coins',name:'+500 coins',price:0,emoji:'üí∞'}
  ];
  items.forEach(it=>{
    const d = document.createElement('div');
    d.style.background = '#fff8fb'; d.style.padding='10px'; d.style.borderRadius='12px'; d.style.textAlign='center';
    d.innerHTML = `<div style="font-size:26px">${it.emoji}</div><div style="font-weight:900;margin-top:6px">${it.name}</div><div style="color:#ff4d9e;font-weight:900">${it.price>0?it.price+'üí∞':'Free'}</div>`;
    const b = document.createElement('button'); b.className='btn'; b.style.marginTop='8px'; b.textContent='Buy';
    b.addEventListener('click', ()=> { alert(it.name + ' demo buy (no persistence)'); });
    d.appendChild(b); shopItemsEl.appendChild(d);
  });
}

/* restart, shuffle, useBomb */
document.getElementById('restart').addEventListener('click', ()=> {
  initGame(true);
});
document.getElementById('shuffle').addEventListener('click', ()=> {
  // shuffle existing tiles (keep images)
  const arr = state.board.slice();
  for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
  state.board = arr;
  render();
});
document.getElementById('useBomb').addEventListener('click', ()=> {
  if(locked) return;
  // place bomb on random existing tile and detonate
  const valid = state.board.map((t,i)=> t ? i : -1).filter(i=>i>=0);
  if(valid.length === 0) return;
  const idx = valid[Math.floor(Math.random()*valid.length)];
  state.board[idx] = makeTile(IMAGE_BASE + BOMB_IMG);
  state.board[idx].power = {type:'bomb'};
  render();
  setTimeout(()=>{
    // remove neighbors
    const removed = new Set();
    const r0 = Math.floor(idx/COLS), c0 = idx%COLS;
    for(let dr=-1;dr<=1;dr++) for(let dc=-1;dc<=1;dc++){
      const nr=r0+dr, nc=c0+dc;
      if(nr>=0 && nr<ROWS && nc>=0 && nc<COLS) removed.add(nr*COLS+nc);
    }
    Array.from(removed).forEach(i=> { CELL[i].btn.classList.add('pop'); state.board[i] = null; });
    state.score += removed.size * 12; updateHUD();
    setTimeout(()=> resolveChain(), 260);
  }, 240);
});

/* ====== HUD ====== */
function updateHUD(){
  scoreEl.textContent = state.score;
  movesEl.textContent = state.moves;
  comboText.textContent = `Combo √ó${Math.max(1, state.combo-1)}`;
}

/* ====== RESIZE & FIT ====== */
function fitTiles(){
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 6;
  const wrap = document.querySelector('.board-area').getBoundingClientRect();
  const availW = Math.min(wrap.width - 16, window.innerWidth - 48);
  const candidateW = Math.floor((availW - gap*(COLS-1))/COLS);
  const desired = Math.max(36, Math.min(candidateW, 80));
  document.documentElement.style.setProperty('--tile', desired + 'px');
}

/* ====== INIT GAME ====== */
function initGame(fromStart=false){
  state.nextId = 1;
  fillInitialBoard();
  state.score = 0; state.moves = 40; state.combo = 1;
  fitTiles(); render();
}

/* ====== STARTUP ====== */
async function start(){
  await detectImages();
  createCells();
  initGame();
  updateHUD();
  window.addEventListener('resize', ()=> { clearTimeout(window._resizeTO); window._resizeTO = setTimeout(()=>{ fitTiles(); render(); }, 120); });
  // service worker registration (if exists)
  if('serviceWorker' in navigator){
    navigator.serviceWorker.register('/service-worker.js').then(()=> console.log('SW registered')).catch(()=>{});
  }
}

/* Expose for debug */
window._game = { state, render, initGame, start };

/* run */
start();
</script>
</body>
</html>
