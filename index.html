<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Candy ‚Äî Fixed boxes & proper moves</title>
<style>
:root{ --cols:8; --tile:74px; --gap:6px; --accent:#ff4d9e; --pop:300ms; }
*{box-sizing:border-box}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff)}
body{display:flex;align-items:center;justify-content:center;padding:18px}
.card{width:100%;max-width:920px;background:#fff;border-radius:14px;padding:18px;box-shadow:0 18px 48px rgba(20,20,50,.06)}
.header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
.title{font-weight:900;font-size:20px}
.hud{color:#666}
.grid-wrap{background:linear-gradient(180deg,#fff,#fff7fb);padding:14px;border-radius:12px;box-shadow:inset 0 8px 30px rgba(250,240,250,0.4)}
.grid{
  display:grid;
  grid-template-columns: repeat(var(--cols), var(--tile));
  grid-auto-rows: var(--tile);
  gap: var(--gap);
  justify-content:center;
  align-content:center;
}
.cell{
  width:var(--tile); height:var(--tile);
  border-radius:12px; background:rgba(255,255,255,0.98);
  display:flex;align-items:center;justify-content:center; position:relative;
  box-shadow:0 6px 14px rgba(10,10,30,0.06); border:1px solid rgba(0,0,0,0.03);
  padding:0; overflow:hidden; cursor:grab;
}
.cell img{ width:88%; height:88%; object-fit:contain; display:block; pointer-events:none; user-select:none; -webkit-user-drag:none; }
.cell.hidden{visibility:hidden}
.pop{animation:pop var(--pop) cubic-bezier(.2,.9,.2,1) forwards}
@keyframes pop{0%{transform:scale(1);opacity:1}50%{transform:scale(1.35)}100%{transform:scale(0);opacity:0}}
.controls{display:flex;gap:12px;justify-content:center;margin-top:14px}
.btn{padding:10px 14px;border-radius:12px;border:0;background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff;font-weight:800;cursor:pointer}
.note{font-size:13px;color:#666;margin-top:10px;text-align:center}
@media(max-width:720px){ :root{ --tile:56px; --gap:4px } .title{font-size:18px} }
</style>
</head>
<body>
  <div class="card">
    <div class="header">
      <div class="title">Candy ‚Äî Boxed & Proper Moves</div>
      <div class="hud">Score: <span id="score">0</span></div>
    </div>

    <div class="grid-wrap">
      <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
    </div>

    <div class="controls">
      <button id="restart" class="btn">Restart</button>
      <button id="shuffle" class="btn">Shuffle</button>
    </div>

    <div class="note">Images should be in <code>images/</code> folder. Change `IMAGE_NAMES` in script if different.</div>
  </div>

<script>
/* Simple reliable candy grid:
   - Tiles are objects {id, src}
   - render() only sets img.src from state.board
   - swap(i,j) swaps tile objects (no random creation on swap)
*/
const COLS = 8, ROWS = 8, SIZE = COLS*ROWS;
const IMAGE_BASE = 'images/';
const IMAGE_NAMES = ['candy1.png','candy2.png','candy3.png','candy4.png','candy5.png','candy6.png','candy7.png','candy8.png'];
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');

let pool = IMAGE_NAMES.map(n => IMAGE_BASE + n);
let state = { nextId:1, board: new Array(SIZE).fill(null), score:0 };
let CELLS = [];

/* Safe loader: keep only images that exist (optional) */
function tryLoad(url){ return new Promise(res=>{ const i=new Image(); i.onload=()=>res({ok:true,url}); i.onerror=()=>res({ok:false,url}); i.src = url; }); }
async function detectPool(){
  const checks = await Promise.all(pool.map(u=>tryLoad(u)));
  const ok = checks.filter(r=>r.ok).map(r=>r.url);
  if(ok.length) pool = ok;
  else pool = ['data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="100%" height="100%" fill="%23eee"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="%23222" font-size="10">üç≠</text></svg>'];
}

/* create grid cells once */
function createCells(){
  gridEl.innerHTML = '';
  CELLS = [];
  gridEl.style.setProperty('--cols', COLS);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    const img = document.createElement('img');
    img.alt = 'candy';
    btn.appendChild(img);
    btn.addEventListener('pointerdown', onPointerDown);
    gridEl.appendChild(btn);
    CELLS.push({btn, img});
  }
}

/* rendering: only set src from state.board, hide empty cells */
function render(){
  for(let i=0;i<SIZE;i++){
    const tile = state.board[i];
    const {btn,img} = CELLS[i];
    // remove stray text nodes
    btn.childNodes.forEach(n=>{ if(n.nodeType===3) n.remove(); });
    if(tile){
      if(img.dataset.src !== tile.src){
        img.dataset.src = tile.src;
        img.src = tile.src;
      }
      btn.classList.remove('hidden');
    } else {
      img.src = '';
      img.dataset.src = '';
      btn.classList.add('hidden');
    }
  }
  scoreEl.textContent = state.score;
}

/* helpers */
function makeTile(src){ return { id: state.nextId++, src }; }
function randomSrc(){ return pool[Math.floor(Math.random()*pool.length)]; }

/* matching (by src) */
function findMatches(board){
  const matches = [];
  // rows
  for(let r=0;r<ROWS;r++){
    let run=[r*COLS];
    for(let c=1;c<COLS;c++){
      const p=r*COLS+c-1, i=r*COLS+c;
      if(board[i] && board[p] && board[i].src === board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // cols
  for(let c=0;c<COLS;c++){
    let run=[c];
    for(let r=1;r<ROWS;r++){
      const p=(r-1)*COLS+c, i=r*COLS+c;
      if(board[i] && board[p] && board[i].src === board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* gravity + refill: create new tiles only here */
function gravityRefill(){
  const newBoard = new Array(SIZE).fill(null);
  for(let c=0;c<COLS;c++){
    const colTiles = [];
    for(let r=ROWS-1;r>=0;r--){
      const idx = r*COLS + c;
      if(state.board[idx]) colTiles.push(state.board[idx]);
    }
    let write = ROWS-1;
    for(const t of colTiles){
      newBoard[write*COLS + c] = t; write--;
    }
    // fill remaining with NEW tiles (from pool)
    for(let r=write; r>=0; r--){
      newBoard[r*COLS + c] = makeTile(randomSrc());
    }
  }
  state.board = newBoard;
}

/* Resolve chain recursively until no matches */
function resolveChain(){
  const matches = findMatches(state.board);
  if(matches.length === 0) return;
  const removeSet = new Set();
  matches.forEach(run => run.forEach(i => removeSet.add(i)));
  const removal = Array.from(removeSet).sort((a,b)=>a-b);
  // award score
  state.score += removal.length * 10;
  // animate pop class on removed cells
  removal.forEach(i => {
    const el = CELLS[i] && CELLS[i].btn;
    if(el) el.classList.add('pop');
    state.board[i] = null;
  });
  render();
  // after pop animation -> gravity & refill -> continue
  setTimeout(()=>{
    // clear pop classes (safe)
    CELLS.forEach(x => x.btn.classList.remove('pop'));
    gravityRefill();
    render();
    // small delay before checking next chain
    setTimeout(()=> resolveChain(), 220);
  }, 240);
}

/* swap two tiles (preserve objects) */
function swap(i,j){ [state.board[i], state.board[j]] = [state.board[j], state.board[i]]; }

/* pointer drag / swap implementation */
let dragging = false, startIdx = null, pId = null;
function onPointerDown(e){
  // only left button / primary pointer
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true; startIdx = Number(el.dataset.index); pId = e.pointerId;
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(idx !== startIdx && isAdjacent(idx, startIdx)){
    // do the swap
    swap(startIdx, idx);
    render(); // immediate visual swap
    // check matches
    setTimeout(()=>{
      const matches = findMatches(state.board);
      if(matches.length > 0){
        resolveChain();
      } else {
        // revert if no match
        swap(startIdx, idx);
        render();
      }
    }, 140);
    // stop listening after one swap
    dragging = false;
    document.removeEventListener('pointermove', onPointerMove);
    document.removeEventListener('pointerup', onPointerUp);
  }
}
function onPointerUp(e){
  dragging = false; startIdx = null; pId = null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){
  if(a==null||b==null) return false;
  const r1 = Math.floor(a/COLS), c1 = a%COLS, r2 = Math.floor(b/COLS), c2 = b%COLS;
  return Math.abs(r1-r2) + Math.abs(c1-c2) === 1;
}

/* controls */
document.getElementById('restart').addEventListener('click', initBoard);
document.getElementById('shuffle').addEventListener('click', ()=>{
  // shuffle srcs but keep tile objects stable
  const srcs = state.board.map(t => t ? t.src : randomSrc()).sort(()=>Math.random()-0.5);
  for(let i=0;i<SIZE;i++){
    if(state.board[i]) state.board[i].src = srcs[i];
    else state.board[i] = makeTile(srcs[i]);
  }
  render();
});

/* init board (no immediate matches) */
function initBoard(){
  state.nextId = 1;
  state.score = 0;
  // fill with random tiles
  for(let i=0;i<SIZE;i++) state.board[i] = makeTile(randomSrc());
  // shuffle until no matches
  let tries = 0;
  while(findMatches(state.board).length > 0 && tries++ < 800){
    const arr = state.board.map(t=>t.src).sort(()=>Math.random()-0.5);
    for(let i=0;i<SIZE;i++) state.board[i].src = arr[i];
  }
  render();
}

/* start sequence */
(async function start(){
  await detectPool();
  pool.forEach(u=>{ const img=new Image(); img.src = u; });
  createCells();
  initBoard();
})();
</script>
</body>
</html>
