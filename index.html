<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Candy Match ‚Äî Full</title>
<style>
  :root{
    --cols:8; --rows:8; --gap:8px; --tile:60px; --accent:#ff4d9e;
    --pop-dur:420ms; --fall-dur:420ms; --particle-color: rgba(255,90,140,0.95);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
  .stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
  .card{width:100%;max-width:1100px;height:calc(100vh - 24px);padding:14px;border-radius:16px;background:#fff;box-shadow:0 30px 80px rgba(20,20,50,.06);display:flex;flex-direction:column;gap:12px;overflow:hidden}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:26px}
  .meta{font-size:13px;color:#666}
  .hud{display:flex;gap:10px;align-items:center}
  .pill{background:linear-gradient(180deg,#fff,#fff8fb);padding:8px 12px;border-radius:999px;font-weight:700;display:flex;flex-direction:column;align-items:center;min-width:72px;box-shadow:0 8px 18px rgba(0,0,0,0.04)}
  .coins{display:flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;background:linear-gradient(90deg,#fff5f9,#fff)}
  .main{flex:1 1 auto;display:flex;gap:12px;min-height:0}
  .left{flex:1 1 auto;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;min-height:0;padding:6px}
  .grid-wrap{width:100%;max-width:760px;min-width:260px;min-height:320px;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative;padding:10px;border-radius:12px;background:linear-gradient(180deg,#fff,#fff7fb)}
  .grid-inner{position:absolute;left:50%;top:50%;transform-origin:center center;transform:translate(-50%,-50%) scale(1)}
  .grid{display:grid;grid-template-columns:repeat(var(--cols), var(--tile));grid-auto-rows:var(--tile);gap:var(--gap);pointer-events:auto}
  .cell{width:var(--tile);height:var(--tile);border-radius:12px;display:flex;align-items:center;justify-content:center;font-size:calc(var(--tile)*0.55);background:linear-gradient(180deg,#fff,#fff6f9);border:1px solid rgba(0,0,0,0.06);box-shadow:0 12px 30px rgba(10,10,30,0.05);cursor:grab;user-select:none;position:relative;touch-action:none;transition:transform .12s}
  .cell.empty{background:linear-gradient(180deg,#fbfbfd,#fff);opacity:.8}
  .cell.pop{animation:popAnim var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
  @keyframes popAnim{0%{transform:scale(1);opacity:1}45%{transform:scale(1.4)}100%{transform:scale(0);opacity:0}}
  .stripe-h{box-shadow:0 0 0 4px rgba(255,140,180,0.12) inset}
  .stripe-v{box-shadow:0 0 0 4px rgba(140,180,255,0.12) inset}
  .power-star{position:absolute;right:6px;top:6px;font-size:12px}
  .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .btn{padding:10px 12px;border-radius:12px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
  .btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
  .footer{flex:0 0 auto;display:flex;align-items:center;justify-content:space-between;padding:6px 2px;gap:12px}
  .progress{height:12px;width:160px;background:#eee;border-radius:999px;overflow:hidden}
  .progress i{display:block;height:100%;width:0;background:linear-gradient(90deg,#ff9ac8,#ff6aa8);transition:width 300ms ease}

  /* particle layer (absolute over grid) */
  .particle-layer{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none;overflow:visible}

  /* modal/shop */
  .modal-bg{position:fixed;left:0;top:0;right:0;bottom:0;background:rgba(8,6,14,0.36);display:none;align-items:center;justify-content:center;z-index:999}
  .modal{width:92%;max-width:760px;background:#fff;border-radius:14px;padding:14px;box-shadow:0 30px 80px rgba(10,10,30,0.25);max-height:86vh;overflow:auto}
  .store-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px}
  .store-item{background:linear-gradient(180deg,#fff,#fff9fb);padding:10px;border-radius:12px;display:flex;flex-direction:column;align-items:center;gap:8px;box-shadow:0 10px 30px rgba(0,0,0,0.04)}
  .inv-row{display:flex;gap:8px;align-items:center}
  .combo-fly{position:fixed;left:50%;top:20%;transform:translateX(-50%);padding:14px 18px;border-radius:12px;background:linear-gradient(90deg,#fff,#fff7f9);font-weight:900;z-index:2000;box-shadow:0 30px 70px rgba(30,20,60,0.12)}
  .shake{animation:shake .42s ease}
  @keyframes shake{0%{transform:translateX(0)}25%{transform:translateX(-6px)}50%{transform:translateX(6px)}75%{transform:translateX(-3px)}100%{transform:translateX(0)}}

  @media(max-width:920px){ .right{display:none} .card{padding:10px} .store-grid{grid-template-columns:repeat(2,1fr)} .grid-wrap{min-height:360px} }
</style>
</head>
<body>
  <div class="stage">
    <div class="card" id="card">
      <header>
        <div class="brand">
          <div class="logo">üç≠</div>
          <div>
            <div style="font-weight:900;font-size:18px">Candy Match</div>
            <div class="meta">Now with specials, combos & shop</div>
          </div>
        </div>

        <div class="hud">
          <div class="pill"><small>Level</small><div id="level">1</div></div>
          <div class="pill"><small>Score</small><div id="score">0</div></div>
          <div class="pill"><small>Moves</small><div id="moves">20</div></div>
          <div class="coins"><div id="coins">0</div> <div>üí∞</div></div>
        </div>
      </header>

      <div class="main">
        <div class="left">
          <div id="gridWrap" class="grid-wrap">
            <div id="gridInner" class="grid-inner">
              <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
            </div>
            <div class="particle-layer" id="particles"></div>
          </div>

          <div style="width:100%;display:flex;justify-content:center;margin-top:8px;">
            <div class="controls">
              <button id="restart" class="btn primary">Restart</button>
              <button id="shuffle" class="btn">Shuffle</button>
              <button id="useBomb" class="btn">Use Bomb</button>
              <button id="useColor" class="btn">Use Color</button>
              <button id="openShop" class="btn">Shop</button>
            </div>
          </div>
        </div>

        <aside class="right" id="rightPanel">
          <div class="modal" style="box-shadow:none;background:transparent;padding:0;">
            <div style="background:#fbfbff;padding:12px;border-radius:12px;box-shadow:0 10px 30px rgba(30,30,80,0.03)">
              <h4 style="margin:0 0 8px 0">Inventory</h4>
              <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
                <div class="inv-row">üîÄ <strong id="invShuffle">0</strong></div>
                <div class="inv-row">üí£ <strong id="invBomb">0</strong></div>
                <div class="inv-row">‚≠ê <strong id="invColor">0</strong></div>
              </div>

              <h4 style="margin:8px 0 6px 0">Options</h4>
              <div style="display:flex;flex-direction:column;gap:8px">
                <label><input type="checkbox" id="soundToggle" checked> Sound</label>
                <label>Tile size:
                  <select id="tileSizeSelect"><option value="48">Small</option><option value="60" selected>Normal</option><option value="72">Large</option></select>
                </label>
              </div>
            </div>
          </div>
        </aside>
      </div>

      <div class="footer">
        <div id="comboBadge" style="font-weight:900;color:var(--accent)">Combo √ó1</div>
        <div class="progress" aria-hidden><i id="progressBar"></i></div>
      </div>
    </div>
  </div>

  <!-- SHOP modal -->
  <div id="modalBg" class="modal-bg" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h3 style="margin-top:0">Shop</h3>
      <p>Buy power-ups and skins with coins earned in-game.</p>
      <div class="store-grid" style="margin-top:8px">
        <div class="store-item">
          <div style="font-size:28px">üîÄ</div>
          <div>Shuffle</div>
          <div style="font-weight:900;color:#ff5a9f">150</div>
          <button class="buy btn" data-item="shuffle" data-price="150">Buy</button>
        </div>
        <div class="store-item">
          <div style="font-size:28px">üí£</div>
          <div>Bomb</div>
          <div style="font-weight:900;color:#ff5a9f">220</div>
          <button class="buy btn" data-item="bomb" data-price="220">Buy</button>
        </div>
        <div class="store-item">
          <div style="font-size:28px">‚≠ê</div>
          <div>Color-bomb</div>
          <div style="font-weight:900;color:#ff5a9f">350</div>
          <button class="buy btn" data-item="color" data-price="350">Buy</button>
        </div>
        <div class="store-item">
          <div style="font-size:28px">üé®</div>
          <div>Pastel Skin</div>
          <div style="font-weight:900;color:#ff5a9f">500</div>
          <button class="buy btn" data-item="skinPastel" data-price="500">Buy</button>
        </div>
        <div class="store-item">
          <div style="font-size:28px">üíé</div>
          <div>Coins (demo)</div>
          <div style="font-weight:900;color:#ff5a9f">‚Äî</div>
          <button class="buy btn" data-item="coins500" data-price="0">Get 500</button>
        </div>
      </div>
      <div style="margin-top:12px;display:flex;justify-content:flex-end;gap:8px">
        <button id="closeShop" class="btn">Close</button>
      </div>
    </div>
  </div>

<script>
/* --- GAME: Special candies, animations, shop, mobile-friendly --- */

/* CONFIG */
const WIDTH = 8, HEIGHT = 8;
let TYPES = ['üßÄ','üçû','ü•ú','üßá','ü•ñ','üçü','ü•™','üçó','ü´î','üåÆ','üåØ','ü•ô','üßÜ','ü•ò','üç¢','üçß','üßÅ','üç≠','üç¨','üç´','üç©','üç™','üç°','üç•','üç∞','üçπ','üçç','ü•Ø','üçî'];
const grid = document.getElementById('grid');
const gridInner = document.getElementById('gridInner');
const gridWrap = document.getElementById('gridWrap');
const particles = document.getElementById('particles');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const coinsEl = document.getElementById('coins');
const levelEl = document.getElementById('level');
const comboBadge = document.getElementById('comboBadge');
const progressBar = document.getElementById('progressBar');

const invShuffleEl = document.getElementById('invShuffle');
const invBombEl = document.getElementById('invBomb');
const invColorEl = document.getElementById('invColor');
const tileSizeSelect = document.getElementById('tileSizeSelect');
const soundToggle = document.getElementById('soundToggle');

const restartBtn = document.getElementById('restart');
const shuffleBtn = document.getElementById('shuffle');
const useBombBtn = document.getElementById('useBomb');
const useColorBtn = document.getElementById('useColor');
const openShopBtn = document.getElementById('openShop');
const modalBg = document.getElementById('modalBg');
const closeShopBtn = document.getElementById('closeShop');
const buyButtons = document.querySelectorAll('.buy');

let board = [], nextId = 1, score = 0, moves = 20, coins = 0, level = 1;
let inv = { shuffle:0, bomb:0, color:0 };
let dragging=false, pointerId=null, lastIndex=null, locked=false, combo=1;

/* UTIL */
function makeTile(type){ return { id: nextId++, type: type || TYPES[Math.floor(Math.random()*TYPES.length)], power: null }; }
function randTile(){ return makeTile(); }
function cloneBoard(b){ return b.map(t => t ? {...t} : null); }

/* SIZE & center */
function updateTileSizeAndCenter(){
  const gap = 8;
  const areaW = Math.max(260, gridWrap.clientWidth - 16);
  const areaH = Math.max(260, gridWrap.clientHeight - 16);
  const tileByW = Math.floor((areaW - (WIDTH-1)*gap) / WIDTH);
  const tileByH = Math.floor((areaH - (HEIGHT-1)*gap) / HEIGHT);
  let base = Math.max(44, Math.min(tileByW, tileByH));
  const forced = Number(tileSizeSelect.value) || base;
  base = forced;
  document.documentElement.style.setProperty('--tile', base + 'px');
  const requiredW = base*WIDTH + gap*(WIDTH-1);
  const requiredH = base*HEIGHT + gap*(HEIGHT-1);
  const scale = Math.min(1, areaW/requiredW, areaH/requiredH);
  gridInner.style.transform = `translate(-50%,-50%) scale(${scale})`;
}

/* RENDER */
function render(baseMap){
  grid.innerHTML = '';
  grid.style.setProperty('--cols', WIDTH);
  for(let i=0;i<WIDTH*HEIGHT;i++){
    const t = board[i];
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    if(t){
      btn.dataset.id = t.id;
      btn.innerHTML = `<span>${t.type}</span>${t.power ? `<div class="power-star">${powerSymbol(t.power)}</div>` : ''}`;
      if(t.skin) { btn.style.filter = t.skin; }
      if(baseMap && baseMap[t.id]) {
        btn.style.transform = `translateY(${baseMap[t.id]})`;
        // animate to 0
        requestAnimationFrame(()=> {
          requestAnimationFrame(()=> {
            btn.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1), opacity 200ms`;
            btn.style.transform = 'translateY(0)';
          });
        });
      }
    } else {
      btn.classList.add('empty');
      btn.innerHTML = `<span></span>`;
    }
    btn.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(btn);
  }
}

/* POWER symbol */
function powerSymbol(p){
  if(!p) return '';
  if(p.type === 'stripe') return p.dir === 'h' ? '‚Äî' : '‚îÇ';
  if(p.type === 'bomb') return 'üí£';
  if(p.type === 'color') return '‚òÖ';
  return '';
}

/* MATCH detection */
function findMatches(bd){
  const matches=[];
  // rows
  for(let r=0;r<HEIGHT;r++){
    let run=[r*WIDTH];
    for(let c=1;c<WIDTH;c++){
      const p=r*WIDTH+c-1, i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].type===bd[p].type) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // cols
  for(let c=0;c<WIDTH;c++){
    let run=[c];
    for(let r=1;r<HEIGHT;r++){
      const p=(r-1)*WIDTH+c, i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].type===bd[p].type) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* detect specials: 4->stripe, 5->color, T/L -> bomb approx */
function detectSpecials(matches){
  const map = {};
  matches.forEach(run=>{
    if(run.length >= 5){
      const idx = run[Math.floor(run.length/2)]; map[idx] = {type:'color'};
    } else if(run.length === 4){
      // horizontal or vertical?
      const a=run[0], b=run[1];
      const isH = (Math.floor(a/WIDTH) === Math.floor(b/WIDTH));
      const idx = run[Math.floor(run.length/2)];
      map[idx] = {type:'stripe', dir: isH ? 'h' : 'v'};
    }
  });
  // detect overlapped (T/L) shapes -> bomb
  const counts = {};
  matches.forEach(run => run.forEach(i => counts[i] = (counts[i]||0)+1));
  Object.keys(counts).forEach(k => {
    if(counts[k] >= 2) map[Number(k)] = {type:'bomb'};
  });
  return map;
}

/* SWAP */
function swapIndices(i,j){ [board[i], board[j]] = [board[j], board[i]]; }

/* PARTICLES */
function burstParticles(x,y,color,amount=18){
  // x,y in client coords relative to particle layer
  const layerRect = particles.getBoundingClientRect();
  const ox = x - layerRect.left;
  const oy = y - layerRect.top;
  for(let i=0;i<amount;i++){
    const p = document.createElement('div');
    p.style.position='absolute'; p.style.left = ox+'px'; p.style.top = oy+'px';
    p.style.width = p.style.height = (6 + Math.random()*8) + 'px';
    p.style.borderRadius='50%';
    p.style.background = color || getComputedStyle(document.documentElement).getPropertyValue('--particle-color');
    p.style.opacity = '1';
    p.style.transform = `translate(-50%,-50%)`;
    p.style.pointerEvents='none';
    particles.appendChild(p);
    const angle = Math.random()*Math.PI*2;
    const dist = 24 + Math.random()*48;
    const nx = Math.cos(angle)*dist;
    const ny = Math.sin(angle)*dist;
    p.animate([
      { transform: `translate(-50%,-50%) translate(0px,0px) scale(1)`, opacity:1 },
      { transform: `translate(-50%,-50%) translate(${nx}px,${ny}px) scale(.4)`, opacity:0 }
    ], { duration: 600 + Math.random()*200, easing:'cubic-bezier(.2,.8,.2,1)' });
    setTimeout(()=>p.remove(), 1000);
  }
}

/* RESOLVE FLOW: pop -> grant score/coins -> gravity -> refill with fall animation -> chain */
function resolveChain(){
  if(locked) return;
  locked = true;
  combo = 1;
  (function step(){
    const matches = findMatches(board);
    if(matches.length === 0){ locked=false; updateHUD(); return; }
    const removeSet = new Set();
    matches.forEach(run => run.forEach(i => removeSet.add(i)));
    const removeIdx = Array.from(removeSet).sort((a,b)=>a-b);
    const powerMap = detectSpecials(matches);

    // award points/coins
    const removedCount = removeIdx.length;
    score += removedCount * 10 * combo;
    coins += removedCount * 5;
    combo++;
    updateHUD();

    // add power tiles (mark on board as special BEFORE removal so we can place)
    Object.keys(powerMap).forEach(k=>{
      const idx = Number(k);
      // place special on that index later after refill; we'll pass powerMap forward
    });

    // add pop class to DOM elements & particle burst at center of cluster
    if(removeIdx.length > 0){
      // compute cluster center from their DOM positions
      let cx=0, cy=0, count=0;
      removeIdx.forEach(i=>{
        const el = grid.querySelector(`.cell[data-index='${i}']`);
        if(el){
          const r = el.getBoundingClientRect();
          cx += r.left + r.width/2; cy += r.top + r.height/2; count++;
          el.classList.add('pop');
        }
      });
      if(count>0) burstParticles(cx/count, cy/count, null, Math.min(28, 8 + count));
    }

    // remove after pop duration
    setTimeout(()=>{
      // clear board positions
      removeIdx.forEach(i => board[i] = null);

      // gravity: make columns stacks and refill, and compute drop distances for old tiles
      const cols = [];
      for(let c=0;c<WIDTH;c++){
        const stack = [];
        for(let r=HEIGHT-1;r>=0;r--){
          const idx = r*WIDTH + c;
          if(board[idx] !== null) stack.push(board[idx]);
        }
        cols.push(stack);
      }

      // build new board with new tiles on top; compute dropMap
      const newBoard = new Array(WIDTH*HEIGHT).fill(null);
      const dropMap = {}; // tile.id -> translateY
      const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 60;

      for(let c=0;c<WIDTH;c++){
        const stack = cols[c];
        const need = HEIGHT - stack.length;
        // push new tiles (these are "new" above)
        for(let k=0;k<need;k++) stack.push(randTile());
        // fill downwards
        for(let r=HEIGHT-1, si=0; r>=0; r--, si++){
          const tile = stack[si];
          newBoard[r*WIDTH + c] = tile;
          // compute how far it fell: find old row if existed
          let oldIndex = -1;
          for(let oi=0; oi<board.length; oi++){
            const t = board[oi];
            if(t && t.id === tile.id){ oldIndex = oi; break; }
          }
          if(oldIndex === -1){
            // new tile from above, animate from - (si+1) rows to position
            dropMap[tile.id] = `-${(si + 1) * tilePx}px`;
          } else {
            const oldRow = Math.floor(oldIndex / WIDTH);
            const newRow = Math.floor((r*WIDTH + c) / WIDTH);
            const dr = oldRow - newRow;
            if(dr > 0) dropMap[tile.id] = `-${dr * tilePx}px`;
          }
        }
      }

      // attach special power-ups to newBoard based on powerMap centers (approx)
      // We'll place power at the index that corresponds (if present)
      Object.keys(powerMap).forEach(k=>{
        const idx = Number(k);
        // place if inside bounds
        if(idx >=0 && idx < newBoard.length){
          newBoard[idx].power = powerMap[idx];
        }
      });

      board = newBoard;
      // render with dropMap so tiles animate falling
      render(dropMap);

      // small screen shake on big combos
      if(removedCount >= 8){
        document.getElementById('card').classList.add('shake');
        setTimeout(()=>document.getElementById('card').classList.remove('shake'), 420);
      }

      // chain
      setTimeout(()=>{ updateHUD(); setTimeout(step, 300); }, 380);
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 420);
  })();
}

/* handle swap collisions and power activation */
function handleSwapEffects(i,j){
  const Ai = board[i], Aj = board[j];
  if(!Ai || !Aj) return false;
  // If either tile has color-bomb power -> remove all of other type
  if(Ai.power && Ai.power.type === 'color'){
    activateColorBomb(i, Aj.type); return true;
  }
  if(Aj.power && Aj.power.type === 'color'){
    activateColorBomb(j, Ai.type); return true;
  }
  // If either has stripe/bomb on swap -> activate
  if(Ai.power){ activatePowerAt(i); return true; }
  if(Aj.power){ activatePowerAt(j); return true; }
  return false;
}

function activatePowerAt(idx, otherType=null){
  const tile = board[idx];
  if(!tile || !tile.power) return;
  const p = tile.power;
  const removed = new Set();
  if(p.type === 'stripe'){
    if(p.dir === 'h'){
      const r = Math.floor(idx / WIDTH);
      for(let c=0;c<WIDTH;c++) removed.add(r*WIDTH + c);
    } else {
      const c = idx % WIDTH;
      for(let r=0;r<HEIGHT;r++) removed.add(r*WIDTH + c);
    }
  } else if(p.type === 'bomb'){
    const r0 = Math.floor(idx / WIDTH), c0 = idx % WIDTH;
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      const nr = r0 + dr, nc = c0 + dc;
      if(nr>=0 && nr<HEIGHT && nc>=0 && nc<WIDTH) removed.add(nr*WIDTH + nc);
    }
  } else if(p.type === 'color'){
    const target = otherType || tile.type;
    for(let i=0;i<board.length;i++) if(board[i] && board[i].type === target) removed.add(i);
  }
  // animate and remove
  const arr = Array.from(removed);
  arr.forEach(i=>{
    const el = grid.querySelector(`.cell[data-index='${i}']`);
    if(el) el.classList.add('pop');
    board[i] = null;
  });
  // award coins/score
  score += arr.length * 12;
  coins += arr.length * 6;
  updateHUD();
  // gravity + refill after pop
  setTimeout(()=>{ // reuse resolveChain's gravity logic simple: call resolveChain after clearing
    resolveChain();
  }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 420);
}

/* activate color bomb */
function activateColorBomb(idx, targetType){
  for(let i=0;i<board.length;i++) if(board[i] && board[i].type === targetType) board[i] = null;
  score += 200;
  coins += 100;
  render();
  setTimeout(()=>resolveChain(), 260);
}

/* POINTER drag swap */
function onPointerDown(e){
  if(locked) return;
  if(e.button && e.button !== 0) return;
  e.preventDefault();
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true; pointerId = e.pointerId; lastIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
    // swap
    swapIndices(lastIndex, idx);
    render();
    moves = Math.max(0, moves-1);
    updateHUD();
    // check power effects
    const activated = handleSwapEffects(lastIndex, idx);
    if(!activated){
      const matches = findMatches(board);
      if(matches.length>0) resolveChain();
      else {
        // revert after short vibration/feedback
        setTimeout(()=>{ swapIndices(lastIndex, idx); render(); }, 200);
      }
    }
    lastIndex = idx;
  }
}
function onPointerUp(e){
  dragging=false; pointerId=null; lastIndex=null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
  if(moves <= 0) setTimeout(()=>alert('Out of moves ‚Äî Restart to try again'), 120);
}
function isAdjacent(a,b){
  if(a==null||b==null) return false;
  const r1=Math.floor(a/WIDTH), c1=a%WIDTH, r2=Math.floor(b/WIDTH), c2=b%WIDTH;
  return Math.abs(r1-r2) + Math.abs(c1-c2) === 1;
}

/* HINT */
function findHint(){
  for(let i=0;i<board.length;i++){
    const r=Math.floor(i/WIDTH), c=i%WIDTH;
    const dirs=[[0,1],[1,0],[0,-1],[-1,0]];
    for(const d of dirs){
      const nr=r+d[0], nc=c+d[1];
      if(nr<0||nr>=HEIGHT||nc<0||nc>=WIDTH) continue;
      const j = nr*WIDTH + nc;
      swapIndices(i,j);
      const m = findMatches(board);
      swapIndices(i,j);
      if(m.length>0) return [i,j];
    }
  }
  return null;
}

/* SHOP */
openShopBtn.addEventListener('click', ()=>{ modalBg.style.display='flex'; modalBg.setAttribute('aria-hidden','false'); });
closeShopBtn.addEventListener('click', ()=>{ modalBg.style.display='none'; modalBg.setAttribute('aria-hidden','true'); });
modalBg.addEventListener('click', (e)=>{ if(e.target === modalBg){ modalBg.style.display='none'; modalBg.setAttribute('aria-hidden','true'); } });

buyButtons.forEach(b=>{
  b.addEventListener('click', ()=>{
    const item = b.dataset.item;
    const price = Number(b.dataset.price) || 0;
    if(price > coins){ showToast('Not enough coins'); return; }
    if(item === 'shuffle'){ coins -= price; inv.shuffle++; updateHUD(); showToast('Shuffle added'); }
    else if(item === 'bomb'){ coins -= price; inv.bomb++; updateHUD(); showToast('Bomb added'); }
    else if(item === 'color'){ coins -= price; inv.color++; updateHUD(); showToast('Color-bomb added'); }
    else if(item === 'skinPastel'){ coins -= price; applySkin('pastel'); showToast('Pastel skin applied'); }
    else if(item === 'coins500'){ coins += 500; showToast('500 coins added (dev)'); }
    updateHUD(); modalBg.style.display='none';
  });
});

/* inventory quick use */
document.getElementById('invShuffle').parentElement.addEventListener('click', ()=>{
  if(inv.shuffle>0){ inv.shuffle--; shuffleBoard(); updateHUD(); showToast('Shuffle used'); }
});
document.getElementById('invBomb').parentElement.addEventListener('click', ()=>{
  if(inv.bomb>0){ inv.bomb--; useBombNow(); updateHUD(); showToast('Bomb used'); }
});
document.getElementById('invColor').parentElement.addEventListener('click', ()=>{
  if(inv.color>0){ inv.color--; useColorNow(); updateHUD(); showToast('Color-bomb used'); }
});

/* use bomb/color buttons */
useBombBtn.addEventListener('click', ()=>{ if(inv.bomb>0){ inv.bomb--; useBombNow(); updateHUD(); showToast('Bomb used'); } else showToast('No bomb in inventory'); });
useColorBtn.addEventListener('click', ()=>{ if(inv.color>0){ inv.color--; useColorNow(); updateHUD(); showToast('Color used'); } else showToast('No color-bomb'); });

function useBombNow(){
  // activate bomb at center-most filled tile
  const center = Math.floor((WIDTH*HEIGHT)/2);
  activatePowerAt(center);
}
function useColorNow(){
  // choose random existing type and remove
  const types = board.filter(b=>b).map(b=>b.type);
  if(types.length===0) return;
  const t = types[Math.floor(Math.random()*types.length)];
  for(let i=0;i<board.length;i++) if(board[i] && board[i].type === t) board[i] = null;
  render();
  setTimeout(()=>resolveChain(), 360);
}

/* SHUFFLE */
shuffleBtn.addEventListener('click', ()=>{ if(inv.shuffle>0){ inv.shuffle--; updateHUD(); showToast('Shuffle used'); } shuffleBoard(); });

function shuffleBoard(){
  board = board.sort(()=>Math.random()-0.5);
  render();
}

/* SKIN */
function applySkin(name){
  if(name === 'pastel'){
    // apply CSS filter to each tile (simple demo)
    grid.querySelectorAll('.cell').forEach(c => { c.style.filter = 'saturate(.9) hue-rotate(10deg)'; });
  } else {
    grid.querySelectorAll('.cell').forEach(c => { c.style.filter = ''; });
  }
}

/* HUD updates */
function updateHUD(){
  scoreEl.textContent = score;
  movesEl.textContent = moves;
  coinsEl.textContent = coins;
  levelEl.textContent = level;
  invShuffleEl.textContent = inv.shuffle;
  invBombEl.textContent = inv.bomb;
  invColorEl.textContent = inv.color;
  comboBadge.textContent = `Combo √ó${Math.max(1, combo-1)}`;
  progressBar.style.width = Math.min(100, Math.round(score/800*100)) + '%';
}

/* Toast */
let toastTimer = null;
function showToast(msg, ms=900){
  const t = document.createElement('div');
  t.className = 'combo-fly';
  t.textContent = msg;
  document.body.appendChild(t);
  clearTimeout(toastTimer);
  toastTimer = setTimeout(()=>{ t.style.transition='opacity .3s'; t.style.opacity=0; setTimeout(()=>t.remove(),350); }, ms);
}

/* INIT BOARD (no starting matches) */
function initBoard(){
  nextId = 1;
  board = new Array(WIDTH*HEIGHT).fill(null).map(()=>randTile());
  let safety = 0;
  while(findMatches(board).length > 0 && safety++ < 600){
    board = new Array(WIDTH*HEIGHT).fill(null).map(()=>randTile());
  }
  score = 0; moves = 20; coins = 0; level = 1; combo = 1; inv = { shuffle:0, bomb:0, color:0 };
  updateTileSizeAndCenter(); render(); updateHUD();
}

/* render function wrapper used by resolveChain etc. */
function render(dropMap){
  // clear particle layer to avoid overflow (keeps light)
  // but don't clear while particles animating - we'll let them auto-remove
  grid.innerHTML = '';
  grid.style.setProperty('--cols', WIDTH);
  for(let i=0;i<WIDTH*HEIGHT;i++){
    const t = board[i];
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    if(t){
      btn.dataset.id = t.id;
      btn.innerHTML = `<span>${t.type}</span>${t.power ? `<div class="power-star">${powerSymbol(t.power)}</div>` : ''}`;
      if(dropMap && dropMap[t.id]){
        btn.style.transform = `translateY(${dropMap[t.id]})`;
        requestAnimationFrame(()=> {
          requestAnimationFrame(()=> {
            btn.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`;
            btn.style.transform = 'translateY(0)';
          });
        });
      } else btn.style.transform = '';
    } else {
      btn.classList.add('empty');
      btn.innerHTML = `<span></span>`;
    }
    btn.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(btn);
  }
  updateHUD();
}

/* pointer handlers are attached in render; initialRender alias */
function initialRender(){
  render();
}

/* HINT */
function findHint(){
  for(let i=0;i<board.length;i++){
    const r=Math.floor(i/WIDTH), c=i%WIDTH;
    const dirs=[[0,1],[1,0],[0,-1],[-1,0]];
    for(const d of dirs){
      const nr=r+d[0], nc=c+d[1];
      if(nr<0||nr>=HEIGHT||nc<0||nc>=WIDTH) continue;
      const j = nr*WIDTH + nc;
      swapIndices(i,j);
      const m = findMatches(board);
      swapIndices(i,j);
      if(m.length>0) return [i,j];
    }
  }
  return null;
}

/* event wiring for restart/hint/resize */
restartBtn.addEventListener('click', ()=>{ initBoard(); showToast('Restarted'); });
document.getElementById('hint').addEventListener('click', ()=>{
  const h = findHint();
  if(!h) showToast('No hints');
  else {
    const el = grid.querySelector(`[data-index='${h[0]}']`);
    if(el) el.animate([{transform:'scale(1)'},{transform:'scale(1.12)'},{transform:'scale(1)'}],{duration:700,iterations:1});
    showToast('Try swapping highlighted');
  }
});

window.addEventListener('resize', ()=>{ updateTileSizeAndCenter(); render(); });

tileSizeSelect.addEventListener('change', ()=>{ updateTileSizeAndCenter(); render(); });

/* simple sounds (beeps) */
function playBeep(){
  if(!soundToggle.checked) return;
  try{
    const o = new AudioContext();
    const o2 = o.createOscillator(); const g = o.createGain();
    o2.type = 'sine'; o2.frequency.value = 880; g.gain.value = 0.06;
    o2.connect(g); g.connect(o.destination); o2.start(); setTimeout(()=>{ o2.stop(); o.close(); }, 80);
  }catch(e){}
}

/* start */
requestAnimationFrame(()=>{ initBoard(); updateTileSizeAndCenter(); });

</script>
</body>
</html>
