<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Candy ‚Äî Boxed (Fits screen)</title>
<style>
:root{
  --cols:8;
  --rows:8;
  --gap:6px;    /* gap between tiles */
  --tile:56px;  /* default ‚Äî overridden by JS */
  --accent:#ff4d9e;
  --pop-dur:280ms;
  --fall-dur:300ms;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
body{display:flex;align-items:center;justify-content:center;padding:12px;min-height:100vh}

/* CARD: centered, boxed, constrained height so game stays inside */
.card{
  width:100%;
  max-width:980px;
  border-radius:16px;
  background:#fff;
  box-shadow:0 18px 48px rgba(20,20,50,.06);
  padding:14px;
  display:flex;
  flex-direction:column;
  gap:12px;
  /* IMPORTANT: limit height relative to viewport so game stays inside */
  max-height: calc(100vh - 32px);
  overflow: hidden; /* prevent content escaping card */
}

/* header */
header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:52px;height:52px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:26px}
.meta{font-size:13px;color:#666}
.hud{display:flex;gap:12px;align-items:center}
.pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:8px 12px;border-radius:40px;box-shadow:0 8px 22px rgba(20,20,60,0.04);font-weight:800}

/* content area */
.content{display:flex;flex-direction:column;gap:10px;flex:1 1 auto;min-height:0}

/* grid container area - this will scroll if needed but stay inside card */
.grid-area{flex:1 1 auto;display:flex;align-items:center;justify-content:center;min-height:0;padding:6px}
.grid-wrap{
  width:100%;
  max-width:860px;
  border-radius:12px;
  background:linear-gradient(180deg,#fff,#fff7fb);
  padding:12px;
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
  box-shadow:inset 0 12px 30px rgba(250,240,250,0.45);
  /* Crucial: allow internal scrolling but keep card clipped */
  overflow:auto;
  max-height: calc(100vh - 220px); /* safe cap so grid area never exceeds card */
}

/* grid itself */
.grid{
  display:grid;
  gap:var(--gap);
  grid-template-columns:repeat(var(--cols), var(--tile));
  grid-auto-rows:var(--tile);
  justify-content:center;
  align-content:center;
  touch-action:none;
  user-select:none;
  padding:6px;
  background: transparent;
}

/* cell */
.cell{
  width:var(--tile);
  height:var(--tile);
  border-radius:14px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:linear-gradient(180deg,#fff,#fffefc);
  box-shadow:0 6px 18px rgba(10,10,30,0.06);
  cursor:grab;
  transition:transform .12s,opacity .12s;
  position:relative;
  border:1px solid rgba(0,0,0,0.04);
  overflow:visible;
  padding:0;
}
.cell img{ width:78%; height:78%; object-fit:contain; pointer-events:none; display:block; }

/* pop */
.cell.pop{animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
@keyframes pop{0%{transform:scale(1);opacity:1}45%{transform:scale(1.4)}100%{transform:scale(0);opacity:0}}

/* controls area & footer */
.controls{display:flex;gap:12px;align-items:center;justify-content:center;padding:6px 2px;flex-wrap:wrap}
.btn{padding:12px 18px;border-radius:14px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
.footer{display:flex;align-items:center;justify-content:space-between;padding:6px 2px;gap:12px}
.note{font-size:12px;color:#888;padding:6px 8px;border-radius:8px;background:linear-gradient(180deg,#fff,#fff7fb)}

/* small screens adjust */
@media(max-width:720px){
  :root{ --gap:6px; }
  .grid-wrap{ max-height: calc(100vh - 240px); padding:10px; }
  .card{ padding:12px; border-radius:12px; }
}
</style>
</head>
<body>
  <div class="card" id="card">
    <header>
      <div class="brand">
        <div class="logo">üç≠</div>
        <div>
          <div style="font-weight:900;font-size:18px">Candy ‚Äî Boxed & Proper Moves</div>
          <div class="meta">Images from images/ folder</div>
        </div>
      </div>
      <div class="hud">
        <div class="pill"><small>Score</small><div id="score">0</div></div>
      </div>
    </header>

    <div class="content">
      <div class="grid-area">
        <div id="gridWrap" class="grid-wrap">
          <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
        </div>
      </div>

      <div class="controls">
        <button id="restart" class="btn primary">Restart</button>
        <button id="shuffle" class="btn">Shuffle</button>
      </div>
    </div>

    <div class="footer">
      <div class="note">Images should be in <code>images/</code> folder</div>
      <div style="width:200px"></div>
    </div>
  </div>

<script>
/* Simple boxed candy ‚Äî loads images from images/ folder (change IMAGE_NAMES if different) */
/* Important: render does NOT create new random tiles when you swap; swap swaps actual tile objects. */
/* Fit algorithm adjusts --tile so entire grid shows inside .grid-wrap when possible */

const WIDTH = 8, HEIGHT = 8, SIZE = WIDTH*HEIGHT;
const IMAGE_NAMES = [
  'candy1.png','candy2.png','candy3.png','candy4.png','candy5.png',
  'candy6.png','candy7.png','candy8.png','candy9.png','candy10.png'
];
const IMAGE_BASE = 'images/';

const grid = document.getElementById('grid');
const gridWrap = document.getElementById('gridWrap');

let pool = [];           // available image URLs (preloaded)
let state = { nextId:1, board:[], score:0 };
let CELL = [];           // dom refs
let dragging=false, pointerId=null, lastIndex=null, locked=false;

/* preload images that exist in images/ */
function tryLoad(url){
  return new Promise(res=>{
    const i=new Image();
    i.onload=()=>res({ok:true,url});
    i.onerror=()=>res({ok:false,url});
    i.src=url;
  });
}
async function detectPool(){
  const res = await Promise.all(IMAGE_NAMES.map(n=>tryLoad(IMAGE_BASE+n)));
  pool = res.filter(r=>r.ok).map(r=>r.url);
  if(pool.length===0){
    // fallback single svg if nothing present
    pool = ['data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="100%" height="100%" fill="%23eee"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="%23222" font-size="10">üç≠</text></svg>'];
  }
}

/* fit tile size so grid fits inside grid-wrap (or uses default) */
function fitTiles(){
  try{
    const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 6;
    const gw = gridWrap.clientWidth - 24; // padding tolerance
    const gh = gridWrap.clientHeight - 24;
    const w = Math.floor((gw - gap*(WIDTH-1)) / WIDTH);
    const h = Math.floor((gh - gap*(HEIGHT-1)) / HEIGHT);
    let size = Math.max(30, Math.min(w, h));
    // if too large, cap by viewport
    if(!isFinite(size) || size < 30) size = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 48;
    document.documentElement.style.setProperty('--tile', size + 'px');
  }catch(e){ console.warn('fitTiles',e); }
}

/* DOM create cells once */
function createCellsOnce(){
  grid.innerHTML=''; CELL=[];
  grid.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className='cell';
    btn.dataset.index=i;
    const img = document.createElement('img'); img.alt='candy'; img.draggable=false;
    btn.appendChild(img);
    btn.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(btn);
    CELL.push({btn, img});
  }
}

/* tile object */
function makeTile(src){ return { id: state.nextId++, src: src || pool[Math.floor(Math.random()*pool.length)] }; }
function randTile(){ return makeTile(); }

/* render: show current state.board; do NOT create random tiles here */
function render(){
  for(let i=0;i<SIZE;i++){
    const tile = state.board[i];
    const el = CELL[i];
    if(!el) continue;
    const {btn,img} = el;
    // remove stray text nodes
    btn.childNodes.forEach(n=>{ if(n.nodeType===3) n.remove(); });
    if(tile){
      if(img.dataset.src !== tile.src){
        img.dataset.src = tile.src;
        img.src = tile.src;
      }
      btn.style.visibility='visible';
      img.style.opacity='1';
    } else {
      img.dataset.src = '';
      img.src = '';
      btn.style.visibility='hidden';
    }
    btn.classList.remove('pop');
    btn.style.transform = '';
    btn.style.transition = '';
  }
  document.getElementById('score').textContent = state.score;
}

/* find matches by src */
function findMatches(bd){
  const matches=[];
  // horizontal
  for(let r=0;r<HEIGHT;r++){
    let run=[r*WIDTH];
    for(let c=1;c<WIDTH;c++){
      const p=r*WIDTH+c-1, i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].src===bd[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // vertical
  for(let c=0;c<WIDTH;c++){
    let run=[c];
    for(let r=1;r<HEIGHT;r++){
      const p=(r-1)*WIDTH+c, i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].src===bd[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* resolve chain: remove, gravity, refill */
function resolveChain(){
  if(locked) return;
  locked=true;
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length===0){ locked=false; render(); return; }
    const removeSet = new Set();
    matches.forEach(run=>run.forEach(i=>removeSet.add(i)));
    const removed = Array.from(removeSet).sort((a,b)=>a-b);
    // add score
    state.score += removed.length * 10;
    // animate pop and nullify
    removed.forEach(i=>{
      const el = CELL[i] && CELL[i].btn;
      if(el) el.classList.add('pop');
      state.board[i] = null;
    });
    render();
    setTimeout(()=>{
      // gravity & refill (create new tiles here)
      const cols=[];
      for(let c=0;c<WIDTH;c++){
        const col=[];
        for(let r=HEIGHT-1;r>=0;r--){
          const idx=r*WIDTH+c;
          if(state.board[idx]) col.push(state.board[idx]);
        }
        cols.push(col);
      }
      const newBoard = new Array(SIZE).fill(null);
      for(let c=0;c<WIDTH;c++){
        const col = cols[c];
        while(col.length < HEIGHT) col.push(randTile());
        for(let r=HEIGHT-1,i=0;r>=0;r--,i++){
          newBoard[r*WIDTH+c] = col[i];
        }
      }
      state.board = newBoard;
      fitTiles(); render();
      setTimeout(()=> step(), 240);
    }, 300);
  })();
}

/* Input handlers - pointer drag swap */
function onPointerDown(e){
  if(locked) return;
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging=true; pointerId=e.pointerId; lastIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
    // swap the tiles (actual objects) ‚Äî no randomization here
    [state.board[lastIndex], state.board[idx]] = [state.board[idx], state.board[lastIndex]];
    render();
    const matches = findMatches(state.board);
    if(matches.length>0){
      resolveChain();
    } else {
      // revert after brief moment
      setTimeout(()=>{ [state.board[lastIndex], state.board[idx]] = [state.board[idx], state.board[lastIndex]]; render(); }, 200);
    }
    lastIndex = idx;
  }
}
function onPointerUp(e){
  dragging=false; pointerId=null; lastIndex=null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){ if(a==null||b==null) return false; const r1=Math.floor(a/WIDTH), c1=a%WIDTH, r2=Math.floor(b/WIDTH), c2=b%WIDTH; return Math.abs(r1-r2)+Math.abs(c1-c2)===1; }

/* controls */
document.getElementById('restart').addEventListener('click', ()=> initBoard());
document.getElementById('shuffle').addEventListener('click', ()=>{
  // shuffle existing tiles (keeps same src)
  const temp = state.board.slice();
  for(let i=temp.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [temp[i], temp[j]]=[temp[j], temp[i]]; }
  state.board = temp;
  render();
});

/* init board (no immediate matches) */
function initBoard(){
  state.nextId=1;
  state.board = new Array(SIZE).fill(null).map(()=>randTile());
  // avoid starting immediate matches
  let tries=0;
  while(findMatches(state.board).length>0 && tries++<600){
    state.board = new Array(SIZE).fill(null).map(()=>randTile());
  }
  state.score = 0;
  fitTiles();
  render();
}

/* resize handling to re-fit tiles */
let rto;
window.addEventListener('resize', ()=>{ clearTimeout(rto); rto=setTimeout(()=>{ fitTiles(); render(); },120); });

/* start */
(async function start(){
  await detectPool();
  pool.forEach(u=>{ const i=new Image(); i.src=u; }); // preload
  createCellsOnce();
  initBoard();
})();

/* debug */
window._game = { state, pool, initBoard };
</script>
</body>
</html>
