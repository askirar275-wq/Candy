<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple Candy — GitHub Images</title>
<style>
  :root{ --cols:8; --tile:64px; --gap:4px; }
  *{box-sizing:border-box}
  body{font-family:Arial,Helvetica,sans-serif;background:#f7fbff;margin:0;display:flex;align-items:center;justify-content:center;height:100vh}
  .board{width: min(760px, 96vmin); padding:12px; background:#fff;border-radius:12px; box-shadow:0 12px 40px rgba(20,20,50,.08)}
  .grid{display:grid;grid-template-columns:repeat(8, var(--tile));gap:var(--gap);justify-content:center}
  .cell{width:var(--tile);height:var(--tile);border-radius:10px;background:#fff;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative}
  .cell img{width:84%;height:84%;object-fit:contain;user-drag:none;user-select:none;pointer-events:none;display:block}
  .controls{display:flex;gap:8px;justify-content:center;margin-top:10px}
  button{padding:8px 12px;border-radius:10px;border:0;background:#ff6aa8;color:#fff;font-weight:700;cursor:pointer}
  .hidden{visibility:hidden}
</style>
</head>
<body>
  <div class="board">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
      <div style="font-weight:900">Simple Candy</div>
      <div id="info">Score: <span id="score">0</span></div>
    </div>

    <div id="grid" class="grid" aria-label="Candy grid"></div>

    <div class="controls">
      <button id="restart">Restart</button>
      <button id="shuffle">Shuffle</button>
    </div>
    <div style="font-size:12px;color:#666;margin-top:8px">Images from folder: <code>images/</code></div>
  </div>

<script>
/*
  Simple Candy — uses images from images/ folder.
  Put your real candy images inside images/ and name them in IMAGE_NAMES.
*/
const COLS = 8, ROWS = 8, SIZE = COLS*ROWS;
const IMAGE_BASE = 'images/'; // relative path on your GitHub Pages repo
// Edit these names to match files you uploaded to images/ on GitHub
const IMAGE_NAMES = [
  'candy1.png','candy2.png','candy3.png','candy4.png','candy5.png',
  'candy6.png','candy7.png','candy8.png','candy9.png','candy10.png'
];

const GRID = document.getElementById('grid');
const SCORE_EL = document.getElementById('score');

let pool = IMAGE_NAMES.map(n => IMAGE_BASE + n);
let board = new Array(SIZE).fill(null);
let nextId = 1;
let score = 0;

let dragging = false, startIndex = null, pointerId = null;

/* Tile factory */
function makeTile(src){
  return { id: nextId++, src };
}

/* fill initial board (no immediate matches) */
function initBoard(){
  nextId = 1; score = 0; updateScore();
  // simple fill then reshuffle until no matches (bounded tries)
  for(let i=0;i<SIZE;i++) board[i] = makeTile(randomSrc());
  let tries=0;
  while(findMatches(board).length>0 && tries++ < 1000){
    // reshuffle srcs only
    const srcs = board.map(t=>t.src).sort(()=>Math.random()-0.5);
    for(let i=0;i<SIZE;i++) board[i].src = srcs[i];
  }
  render();
}

/* choose random image src from pool */
function randomSrc(){ return pool[Math.floor(Math.random()*pool.length)]; }

/* create grid DOM once */
function createGrid(){
  GRID.innerHTML = '';
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    const img = document.createElement('img');
    btn.appendChild(img);
    // pointer events for drag-swap
    btn.addEventListener('pointerdown', onDown);
    GRID.appendChild(btn);
  }
}

/* render board (only update images, do not create new randoms here) */
function render(){
  for(let i=0;i<SIZE;i++){
    const cell = GRID.children[i];
    const img = cell.querySelector('img');
    const tile = board[i];
    if(tile){
      img.src = tile.src;
      img.alt = 'candy';
      cell.classList.remove('hidden');
    } else {
      img.src = '';
      cell.classList.add('hidden');
    }
  }
}

/* swap two indices in board (tile objects) */
function swap(i,j){
  [board[i], board[j]] = [board[j], board[i]];
}

/* pointer handlers */
function onDown(e){
  if(e.button !== 0) return;
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true;
  pointerId = e.pointerId;
  startIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onMove);
  document.addEventListener('pointerup', onUp);
}
function onMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(isAdjacent(startIndex, idx) && idx !== startIndex){
    // perform swap and check matches
    swap(startIndex, idx);
    render();
    // if match -> resolve chain, else revert after small delay
    setTimeout(()=>{
      const matches = findMatches(board);
      if(matches.length > 0){
        resolveChain();
      } else {
        // revert
        swap(startIndex, idx);
        render();
      }
    }, 160);
    // stop current drag to prevent multiple swaps in one drag
    dragging = false;
    document.removeEventListener('pointermove', onMove);
    document.removeEventListener('pointerup', onUp);
  }
}
function onUp(e){
  dragging = false; startIndex = null; pointerId = null;
  document.removeEventListener('pointermove', onMove);
  document.removeEventListener('pointerup', onUp);
}

/* adjacency */
function isAdjacent(a,b){
  if(a==null||b==null) return false;
  const r1 = Math.floor(a / COLS), c1 = a % COLS;
  const r2 = Math.floor(b / COLS), c2 = b % COLS;
  return Math.abs(r1-r2) + Math.abs(c1-c2) === 1;
}

/* find all horizontal & vertical runs length >=3; returns array of runs (array of indices) */
function findMatches(bd){
  const runs = [];
  // horizontal
  for(let r=0;r<ROWS;r++){
    let run=[r*COLS];
    for(let c=1;c<COLS;c++){
      const p=r*COLS+c-1, i=r*COLS+c;
      if(bd[i] && bd[p] && bd[i].src === bd[p].src) run.push(i);
      else { if(run.length>=3) runs.push([...run]); run=[i]; }
    }
    if(run.length>=3) runs.push([...run]);
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let run=[c];
    for(let r=1;r<ROWS;r++){
      const p=(r-1)*COLS+c, i=r*COLS+c;
      if(bd[i] && bd[p] && bd[i].src === bd[p].src) run.push(i);
      else { if(run.length>=3) runs.push([...run]); run=[i]; }
    }
    if(run.length>=3) runs.push([...run]);
  }
  return runs;
}

/* resolve: remove matches, apply gravity, refill (new tiles only here) */
function resolveChain(){
  const matches = findMatches(board);
  if(matches.length === 0) return;
  const removeSet = new Set();
  matches.forEach(run => run.forEach(idx => removeSet.add(idx)));
  const removed = Array.from(removeSet).sort((a,b)=>a-b);
  // add score
  score += removed.length * 10;
  updateScore();
  // mark removed (set to null)
  removed.forEach(i => board[i] = null);
  render();

  // small delay to show removal (no animation here to keep simple)
  setTimeout(()=>{
    // gravity per column
    for(let c=0;c<COLS;c++){
      const colTiles = [];
      for(let r=ROWS-1;r>=0;r--){
        const idx = r*COLS + c;
        if(board[idx]) colTiles.push(board[idx]);
      }
      // fill from bottom
      let write = ROWS-1;
      for(let t of colTiles){
        board[write*COLS + c] = t;
        write--;
      }
      // empty remaining cells become new tiles
      for(let r=write;r>=0;r--){
        board[r*COLS + c] = makeTile(randomSrc());
      }
    }
    render();
    // after refill, check new matches (chain)
    setTimeout(()=> {
      const next = findMatches(board);
      if(next.length>0) resolveChain();
    }, 120);
  }, 200);
}

/* UI helpers */
function updateScore(){ SCORE_EL.textContent = score; }

/* controls */
document.getElementById('restart').addEventListener('click', initBoard);
document.getElementById('shuffle').addEventListener('click', ()=>{
  // shuffle tiles src but keep tile objects
  const srcs = board.map(t=> t ? t.src : randomSrc()).sort(()=>Math.random()-0.5);
  for(let i=0;i<SIZE;i++){
    if(board[i]) board[i].src = srcs[i];
    else board[i] = makeTile(srcs[i]);
  }
  render();
});

/* start */
createGrid();
initBoard();

</script>
</body>
</html>
