<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Candy Match — Bomb ready</title>
<style>
:root{
  --cols:8; --rows:8; --gap:2px; --tile:64px; --accent:#ff4d9e;
  --pop-dur:360ms; --fall-dur:360ms;
}
*{box-sizing:border-box}
body{font-family:Inter,system-ui,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);margin:0;display:flex;justify-content:center;padding:20px}
.container{width:100%;max-width:920px;background:#fff;border-radius:14px;padding:16px;box-shadow:0 20px 60px rgba(10,10,30,0.06)}
.header{display:flex;justify-content:space-between;align-items:center}
.brand{font-weight:900;font-size:20px}
.hud{display:flex;gap:18px;align-items:center}
.hud div{font-size:14px}
.board-wrap{margin-top:14px;display:flex;justify-content:center}
.board{display:grid;gap:var(--gap);grid-template-columns:repeat(var(--cols), var(--tile));grid-auto-rows:var(--tile);background:linear-gradient(180deg,#fff,#fff7fb);padding:10px;border-radius:12px;box-shadow:inset 0 8px 24px rgba(250,240,250,0.4)}
.cell{width:var(--tile);height:var(--tile);display:flex;align-items:center;justify-content:center;border-radius:12px;background:#fff;padding:6px;cursor:grab;user-select:none}
.cell img{width:100%;height:100%;object-fit:contain;pointer-events:none;display:block}
.controls{display:flex;gap:10px;justify-content:center;margin-top:12px}
button{padding:10px 14px;border-radius:12px;border:0;background:#fff;box-shadow:0 10px 28px rgba(10,10,30,.06);font-weight:800;cursor:pointer}
button.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
.progress{height:12px;background:#eee;border-radius:999px;overflow:hidden;width:220px}
.progress i{height:100%;display:block;width:0;background:linear-gradient(90deg,#ff9ac8,#ff6aa8);transition:width 320ms}
@media(max-width:720px){:root{--tile:52px}}
</style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="brand">Candy Match — GitHub images</div>
      <div class="hud"><div>Level <b id="level">1</b></div><div>Score <b id="score">0</b></div><div>Moves <b id="moves">40</b></div></div>
    </div>

    <div class="board-wrap">
      <div id="board" class="board" role="grid" aria-label="Candy grid"></div>
    </div>

    <div class="controls">
      <button class="primary" id="restartBtn">Restart</button>
      <button id="shuffleBtn">Shuffle</button>
      <button id="useBombBtn">Use Bomb</button>
      <div class="progress"><i id="progressBar"></i></div>
    </div>
  </div>

<script>
/* CONFIG — images in your GitHub repo under /images/ */
const IMG_BASE = "https://askirar275-wq.github.io/Candy/images/"; // <- तुम्हारी repo path
const IMAGE_FILES = [
  "candy1.png","candy2.png","candy3.png","candy4.png",
  "candy5.png","candy6.png","candy7.png","candy8.png",
  "candy9.png","candy10.png"
];
const BOMB_FILE = "bomb.jpg"; // bomb image in same folder

const WIDTH = 8, HEIGHT = 8;
const SIZE = WIDTH*HEIGHT;
const boardEl = document.getElementById('board');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const progressBar = document.getElementById('progressBar');

let state = {board: [], score:0, moves:40, nextId:1, combo:1, inv:{bomb:1}};
let dragging=false, pointerId=null, lastIndex=null, locked=false;

/* helper to create tile objects referencing image url and optional power */
function makeTile(img){
  return { id: state.nextId++, img: img || randomCandy(), power: null };
}
function randomCandy(){ return IMG_BASE + IMAGE_FILES[Math.floor(Math.random()*IMAGE_FILES.length)]; }

/* fit tiles to viewport */
function fitTiles(){
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 2;
  const wrapW = Math.min(window.innerWidth - 48, 880);
  const candidate = Math.floor((wrapW - gap*(WIDTH-1)) / WIDTH);
  const size = Math.max(36, Math.min(candidate, 80));
  document.documentElement.style.setProperty('--tile', size + 'px');
}
window.addEventListener('resize', fitTiles);

/* RENDER */
function render(dropMap){
  boardEl.innerHTML = '';
  boardEl.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const t = state.board[i];
    const cell = document.createElement('button');
    cell.className = 'cell';
    cell.dataset.index = i;
    const img = document.createElement('img');
    img.alt = 'candy';
    if(t) img.src = t.img;
    else img.src = '';
    cell.appendChild(img);
    cell.addEventListener('pointerdown', onPointerDown);
    boardEl.appendChild(cell);
  }
  updateHUD();
}

/* INIT board without immediate matches */
function initBoard(){
  state.nextId = 1;
  state.board = new Array(SIZE).fill(null).map(()=>makeTile());
  let tries=0;
  while(findMatches(state.board).length>0 && tries++ < 800){
    state.board = new Array(SIZE).fill(null).map(()=>makeTile());
  }
  state.score=0; state.moves=40; state.combo=1;
  fitTiles(); render();
}

/* MATCH DETECTION (rows + cols) */
function findMatches(bd){
  const matches=[];
  // rows
  for(let r=0;r<HEIGHT;r++){
    let run=[r*WIDTH];
    for(let c=1;c<WIDTH;c++){
      const p=r*WIDTH+c-1,i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].img===bd[p].img) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // cols
  for(let c=0;c<WIDTH;c++){
    let run=[c];
    for(let r=1;r<HEIGHT;r++){
      const p=(r-1)*WIDTH+c,i=r*WIDTH+c;
      if(bd[i] && bd[p] && bd[i].img===bd[p].img) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* detect specials: 4 -> bomb, 5+ -> color-bomb */
function detectSpecials(matches){
  const map = {};
  matches.forEach(run=>{
    if(run.length>=5){
      const idx = run[Math.floor(run.length/2)]; map[idx] = {type:'color'};
    } else if(run.length===4){
      const idx = run[Math.floor(run.length/2)]; map[idx] = {type:'bomb'};
    }
  });
  return map;
}

/* resolve chain -> pop -> gravity -> refill */
function resolveChain(){
  if(locked) return; locked=true; state.combo=1;
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length===0){ locked=false; updateHUD(); return; }
    const specialMap = detectSpecials(matches);
    const removeSet = new Set();
    matches.forEach(run=> run.forEach(i=> removeSet.add(i)));
    const removedIdx = Array.from(removeSet).sort((a,b)=>a-b);
    const removedCount = removedIdx.length;
    state.score += removedCount * 10 * state.combo;
    state.combo++;
    // mark popped cells visually
    removedIdx.forEach(i=>{
      const el = boardEl.querySelector(`.cell[data-index='${i}'] img`);
      if(el) el.style.opacity = 0.06;
      state.board[i] = null;
    });
    setTimeout(()=>{
      // gravity + refill with drop animation
      const cols = [];
      for(let c=0;c<WIDTH;c++){
        const col=[];
        for(let r=HEIGHT-1;r>=0;r--){ const idx=r*WIDTH+c; if(state.board[idx]) col.push(state.board[idx]); }
        cols.push(col);
      }
      const newBoard = new Array(SIZE).fill(null);
      const dropMap = {};
      const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
      const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
      for(let c=0;c<WIDTH;c++){
        const col = cols[c];
        while(col.length < HEIGHT) col.push(makeTile());
        for(let r=HEIGHT-1,i=0;r>=0;r--,i++){
          const tile = col[i];
          newBoard[r*WIDTH+c] = tile;
          if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
        }
      }
      // place special tiles (bomb/color) onto newBoard
      Object.keys(specialMap).forEach(k=>{
        const idx = Number(k);
        if(newBoard[idx]) newBoard[idx].power = specialMap[k];
        else { const pos = newBoard.findIndex(x=>x); if(pos>=0) newBoard[pos].power = specialMap[k]; }
      });
      state.board = newBoard;
      fitTiles(); render(dropMap);
      setTimeout(()=> step(), 320);
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 360);
  })();
}

/* swapping logic + pointer handlers */
function swapIndices(a,b){ [state.board[a], state.board[b]] = [state.board[b], state.board[a]]; }

function onPointerDown(e){
  if(locked) return;
  const el = e.currentTarget; el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging=true; pointerId=e.pointerId; lastIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
    swapIndices(lastIndex, idx); render();
    state.moves = Math.max(0, state.moves-1); updateHUD();
    // check if move created matches
    const matches = findMatches(state.board);
    if(matches.length>0) resolveChain();
    else { setTimeout(()=>{ swapIndices(lastIndex, idx); render(); }, 240); }
    lastIndex = idx;
  }
}
function onPointerUp(e){
  dragging=false; pointerId=null; lastIndex=null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){ if(a==null||b==null) return false; const r1=Math.floor(a/WIDTH), c1=a%WIDTH, r2=Math.floor(b/WIDTH), c2=b%WIDTH; return Math.abs(r1-r2)+Math.abs(c1-c2)===1; }

/* activate bomb at index (3x3) */
function activateBomb(idx){
  const r0=Math.floor(idx/WIDTH), c0=idx%WIDTH;
  const removed = [];
  for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
    const nr=r0+dr, nc=c0+dc;
    if(nr>=0 && nr<HEIGHT && nc>=0 && nc<WIDTH){
      const i = nr*WIDTH + nc;
      if(state.board[i]) { state.board[i] = null; removed.push(i); }
    }
  }
  state.score += removed.length*12;
  render();
  setTimeout(()=> resolveChain(), 260);
}

/* quick use bomb from inventory: place a bomb tile randomly and activate */
function useBombFromInv(){
  if((state.inv&&state.inv.bomb)>0){
    state.inv.bomb--; // consume
    // place bomb at center if available
    const center = Math.floor(SIZE/2);
    if(state.board[center]) state.board[center].img = IMG_BASE + BOMB_FILE;
    render();
    // activate bomb tile at center -> we'll treat bomb tiles by img name match
    setTimeout(()=> activateBomb(center), 200);
  } else alert('No bomb in inventory');
}

/* HUD update */
function updateHUD(){
  scoreEl.textContent = state.score;
  movesEl.textContent = state.moves;
  const pct = Math.min(100, Math.round(state.score/1000*100));
  progressBar.style.width = pct + '%';
}

/* UI hooks */
document.getElementById('restartBtn').addEventListener('click', ()=> initBoard());
document.getElementById('shuffleBtn').addEventListener('click', ()=>{
  state.board = state.board.sort(()=>Math.random()-0.5); render();
});
document.getElementById('useBombBtn').addEventListener('click', useBombFromInv);

/* start */
fitTiles();
initBoard();
updateHUD();

/* expose for debugging */
window._cm = { state, render, resolveChain, activateBomb, makeTile };

</script>
</body>
</html>
