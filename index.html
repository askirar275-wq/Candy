<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Candy Match ‚Äî Fixed Home & Smooth Moves</title>
<style>
:root{
  --cols:8; --rows:8; --gap:6px; --tile:64px; --accent:#ff4d9e;
  --pop-dur:300ms; --fall-dur:320ms;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
body{overflow:auto}
.stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:18px}
.card{width:100%;max-width:920px;padding:18px;border-radius:14px;background:#fff;box-shadow:0 18px 48px rgba(20,20,50,.06);display:flex;flex-direction:column;gap:14px;overflow:visible}
header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:28px}
.meta{font-size:13px;color:#666}
.hud{display:flex;gap:14px;align-items:center}
.hud .pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:10px 18px;border-radius:40px;box-shadow:0 10px 28px rgba(20,20,60,0.04);text-align:center;font-weight:800}

.content{display:flex;flex-direction:column;gap:10px;flex:1 1 auto;min-height:0}

/* grid area */
.grid-area{flex:1 1 auto;display:flex;align-items:center;justify-content:center;min-height:0;padding:6px}
.grid-wrap{width:100%;max-width:860px;border-radius:12px;background:linear-gradient(180deg,#fff,#fff7fb);padding:12px;display:flex;align-items:center;justify-content:center;position:relative;box-shadow:inset 0 8px 30px rgba(250,240,250,0.4);max-height:70vh;overflow:hidden}
.grid{display:grid; gap:var(--gap); grid-template-columns:repeat(var(--cols), var(--tile)); grid-auto-rows:var(--tile); justify-content:center; align-content:center; touch-action:none; user-select:none; position:relative}

/* tile */
.cell{width:var(--tile); height:var(--tile); border-radius:14px; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#fff,#fffefc); box-shadow:0 8px 18px rgba(10,10,30,0.06); cursor:grab; position:relative; overflow:visible; border:1px solid rgba(0,0,0,0.04)}
.cell img{ width:82%; height:82%; object-fit:contain; pointer-events:none; display:block; transition:transform 200ms ease; will-change: transform, opacity; }

/* pop animation on remove */
.cell.pop img{ animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards }
@keyframes pop{0%{transform:scale(1);opacity:1}40%{transform:scale(1.6)}100%{transform:scale(0);opacity:0}}

/* swap translate animation (we set transform on .cell) */
.cell.moving{ transition: transform 220ms cubic-bezier(.2,.8,.2,1); z-index:5; }

/* controls */
.controls{display:flex;gap:12px;justify-content:center;padding:8px 6px}
.btn{padding:12px 18px;border-radius:14px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}

/* footer */
.footer{display:flex;align-items:center;justify-content:space-between;padding:10px 6px;gap:12px}
.note{font-size:13px;color:#888;padding:6px 8px;border-radius:8px;background:linear-gradient(180deg,#fff,#fff7fb);}

/* home & shop overlays */
.overlay-back{ position:fixed; inset:0; background:rgba(0,0,0,0.35); display:flex;align-items:center;justify-content:center; z-index:1000; }
.overlay{ width:90%; max-width:520px; background:#fff; border-radius:16px; padding:18px; box-shadow:0 30px 80px rgba(10,10,30,0.25); text-align:center; transform:translateY(0); }
.overlay h2{ margin-bottom:6px; font-size:22px }
.overlay p{ color:#666; margin-bottom:14px }
.overlay .btn-full{ display:block; width:100%; margin:8px 0; padding:14px 18px; border-radius:12px; font-weight:800; }

/* small screens */
@media(max-width:720px){
  :root{ --tile:52px; --gap:6px; }
  .card{padding:12px}
  .grid-wrap{max-height:62vh}
}
</style>
</head>
<body>
  <!-- HOME overlay -->
  <div id="homeOverlay" class="overlay-back" style="display:flex;">
    <div class="overlay" role="dialog" aria-modal="true" aria-label="Home">
      <h2>üç¨ Candy Match</h2>
      <p>‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è START ‡§¶‡§¨‡§æ‡§è‡§Å‡•§ Shop ‡§∏‡•á powerups ‡§≤‡•á‡§Ç‡•§</p>
      <button id="homeStart" class="btn btn-full primary">Start</button>
      <button id="homeShop" class="btn btn-full">Shop</button>
      <button id="homeSettings" class="btn btn-full">Settings</button>
    </div>
  </div>

  <!-- SHOP overlay (hidden by default) -->
  <div id="shopOverlay" class="overlay-back" style="display:none;">
    <div class="overlay" role="dialog" aria-modal="true" aria-label="Shop">
      <h2>Shop</h2>
      <p>‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™ powerups ‡§∞‡§ñ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç ‚Äî placeholder</p>
      <button id="closeShop" class="btn btn-full primary">Close</button>
    </div>
  </div>

  <div class="stage">
    <div class="card" id="card">
      <header>
        <div class="brand">
          <div class="logo">üç≠</div>
          <div>
            <div style="font-weight:900;font-size:18px">Candy / Fruit Match</div>
            <div class="meta">Images from your GitHub ‚Äî put images in images/ folder</div>
          </div>
        </div>
        <div class="hud">
          <div class="pill"><small>Level</small><div id="level">1</div></div>
          <div class="pill"><small>Score</small><div id="score">0</div></div>
          <div class="pill"><small>Moves</small><div id="moves">40</div></div>
        </div>
      </header>

      <div class="content">
        <div class="grid-area">
          <div id="gridWrap" class="grid-wrap">
            <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
          </div>
        </div>

        <div class="controls">
          <button id="restart" class="btn primary">Restart</button>
          <button id="shuffle" class="btn">Shuffle</button>
          <button id="placeBomb" class="btn">Place Bomb</button>
        </div>
      </div>

      <div class="footer">
        <div class="note">Images loaded from <span id="imgCount">0</span> files ‚Äî folder: <code>images/</code></div>
        <div style="min-width:220px"></div>
      </div>
    </div>
  </div>

<script>
/* ---------- Configuration ---------- */
const WIDTH = 8, HEIGHT = 8, SIZE = WIDTH * HEIGHT;
const IMAGE_BASE = 'images/';
const IMAGE_CANDIDATES = [
  'candy1.png','candy2.png','candy3.png','candy4.png','candy5.png',
  'candy6.png','candy7.png','candy8.png','candy9.png','candy10.png',
  'donut.png','bomb.jpg'
];

/* ---------- DOM references ---------- */
const grid = document.getElementById('grid');
const gridWrap = document.getElementById('gridWrap');
const imgCountEl = document.getElementById('imgCount');
const homeOverlay = document.getElementById('homeOverlay');
const shopOverlay = document.getElementById('shopOverlay');

/* ---------- State ---------- */
let pool = [];             // available image URLs (from detect)
let CELL_ELEMENTS = [];    // {button,img}
let state = { nextId:1, board:[], score:0, moves:40, combo:1 };
let locked=false;
let dragging=false, pointerId=null, lastIndex = null;

/* ---------- Utility: try load an image ---------- */
function tryLoad(url){
  return new Promise(resolve=>{
    const i = new Image();
    i.onload = ()=> resolve({ok:true, url});
    i.onerror = ()=> resolve({ok:false, url});
    i.src = url;
  });
}

/* ---------- Detect images present in repo /images/ ---------- */
async function detectImages(){
  const res = await Promise.all(IMAGE_CANDIDATES.map(n => tryLoad(IMAGE_BASE + n)));
  const ok = res.filter(r => r.ok).map(r => r.url);
  pool = ok.length ? ok : [/* fallback small svg placeholder */ 'data:image/svg+xml;utf8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="100%" height="100%" fill="#eee"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="#222" font-size="12">üç≠</text></svg>')];
  imgCountEl.textContent = ok.length;
  return pool;
}

/* ---------- Layout: fit tile size to available area ---------- */
function fitTiles(){
  try{
    const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 6;
    const cardRect = document.getElementById('card').getBoundingClientRect();
    const headerH = document.querySelector('header').getBoundingClientRect().height;
    const controlsH = document.querySelector('.controls').getBoundingClientRect().height;
    const footerH = document.querySelector('.footer').getBoundingClientRect().height;
    const padTop = parseFloat(getComputedStyle(document.getElementById('card')).paddingTop) || 0;
    const padBottom = parseFloat(getComputedStyle(document.getElementById('card')).paddingBottom) || 0;
    const availH = cardRect.height - headerH - controlsH - footerH - padTop - padBottom - 12;
    const availW = Math.min(gridWrap.getBoundingClientRect().width - 12, cardRect.width - 28);
    const candidateH = Math.floor((availH - gap*(HEIGHT-1)) / HEIGHT);
    const candidateW = Math.floor((availW - gap*(WIDTH-1)) / WIDTH);
    let base = Math.max(18, Math.min(candidateH, candidateW));
    let desired = Math.floor(base * 1.08);
    const neededW = desired * WIDTH + gap*(WIDTH-1);
    const neededH = desired * HEIGHT + gap*(HEIGHT-1);
    if(neededW > availW || neededH > availH) desired = base;
    if(!isFinite(desired) || desired < 18) desired = 18;
    document.documentElement.style.setProperty('--tile', desired + 'px');
  }catch(e){ console.warn('fitTiles error', e); }
}

/* ---------- Create static cells once ---------- */
function createCellsOnce(){
  grid.innerHTML = '';
  CELL_ELEMENTS = [];
  grid.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell'; btn.dataset.index = i; btn.type='button';
    const img = document.createElement('img'); img.alt='candy'; img.draggable=false; img.dataset.src='';
    btn.appendChild(img);
    btn.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(btn);
    CELL_ELEMENTS.push({button:btn, img});
  }
}

/* ---------- Make tile object ---------- */
function makeTile(src){
  return { id: state.nextId++, src: src || pool[Math.floor(Math.random()*pool.length)], power:null };
}
function randTile(){ return makeTile(); }

/* ---------- Render: crucially DO NOT random-fill here ---------- */
function renderFast(dropMap){
  try{
    if(!CELL_ELEMENTS || CELL_ELEMENTS.length !== SIZE) createCellsOnce();
    for(let i=0;i<SIZE;i++){
      const entry = CELL_ELEMENTS[i];
      if(!entry) continue;
      const {button,img} = entry;
      // remove stray text nodes (safety)
      button.childNodes.forEach(n=>{ if(n.nodeType===3) n.remove(); });
      const tile = state.board[i];
      if(tile){
        const desiredSrc = tile.src || '';
        if(img.dataset.src !== desiredSrc){
          img.dataset.src = desiredSrc;
          img.src = desiredSrc;
        }
        button.style.visibility = 'visible';
      } else {
        // empty cell (during animation) ‚Äî hide image
        img.dataset.src = '';
        img.src = '';
        button.style.visibility = 'hidden';
      }
      // reset transforms if any, then apply dropMap (fall animation)
      button.style.transition = '';
      button.style.transform = '';
      if(dropMap && tile && dropMap[tile.id]){
        button.style.transform = `translateY(${dropMap[tile.id]})`;
        requestAnimationFrame(()=> requestAnimationFrame(()=> {
          button.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`;
          button.style.transform = 'translateY(0)';
        }));
      }
      // remove pop class (if present) so next render is clean
      button.classList.remove('pop','moving');
      img.style.transform = '';
    }
    updateHUD();
  }catch(e){ console.error('renderFast error', e); }
}

/* ---------- Matching detection ---------- */
function findMatches(bd){
  const matches = [];
  try{
    for(let r=0;r<HEIGHT;r++){
      let run=[r*WIDTH];
      for(let c=1;c<WIDTH;c++){
        const p=r*WIDTH+c-1,i=r*WIDTH+c;
        if(bd[i] && bd[p] && bd[i].src===bd[p].src) run.push(i);
        else { if(run.length>=3) matches.push([...run]); run=[i]; }
      }
      if(run.length>=3) matches.push([...run]);
    }
    for(let c=0;c<WIDTH;c++){
      let run=[c];
      for(let r=1;r<HEIGHT;r++){
        const p=(r-1)*WIDTH+c,i=r*WIDTH+c;
        if(bd[i] && bd[p] && bd[i].src===bd[p].src) run.push(i);
        else { if(run.length>=3) matches.push([...run]); run=[i]; }
      }
      if(run.length>=3) matches.push([...run]);
    }
  }catch(e){ console.warn('findMatches error', e); }
  return matches;
}

/* ---------- Specials detection (simplified to bomb) ---------- */
function detectSpecials(matches){
  const assign = {};
  matches.forEach(run=>{
    if(run.length>=5) assign[ run[Math.floor(run.length/2)] ] = {type:'bomb'};
    else if(run.length===4) assign[ run[Math.floor(run.length/2)] ] = {type:'bomb'};
  });
  return assign;
}

/* ---------- Small visual burst ---------- */
function burst(x,y,amount=8){
  try{
    amount = Math.min(8, amount);
    const rect = grid.getBoundingClientRect();
    const ox = x - rect.left, oy = y - rect.top;
    for(let i=0;i<amount;i++){
      const p = document.createElement('div');
      p.style.position='absolute'; p.style.left=ox+'px'; p.style.top=oy+'px';
      const size = 6 + Math.random()*8; p.style.width=p.style.height=size+'px';
      p.style.borderRadius='50%'; p.style.background = `rgba(255,90,140,${0.35+Math.random()*0.5})`; p.style.pointerEvents='none';
      grid.parentElement.appendChild(p);
      const angle = Math.random()*Math.PI*2; const dist = 18 + Math.random()*40;
      const nx = Math.cos(angle)*dist, ny = Math.sin(angle)*dist;
      p.animate([{transform:'translate(-50%,-50%) scale(1)', opacity:1},{transform:`translate(-50%,-50%) translate(${nx}px,${ny}px) scale(.3)`, opacity:0}], {duration:450+Math.random()*250, easing:'cubic-bezier(.2,.8,.2,1)'});
      setTimeout(()=>p.remove(),900);
    }
  }catch(e){ console.warn('burst error', e); }
}

/* ---------- Resolve chain: remove matches, gravity, refill (new tiles created only here) ---------- */
function resolveChain(){
  if(locked) return;
  locked=true; state.combo=1;
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length===0){ locked=false; updateHUD(); return; }
    const specialMap = detectSpecials(matches);
    const removeSet = new Set();
    matches.forEach(run=>run.forEach(i=>removeSet.add(i)));
    const removeIdx = Array.from(removeSet).sort((a,b)=>a-b);
    const removedCount = removeIdx.length;
    state.score += removedCount * 12 * state.combo;
    state.combo++; updateHUD();

    // remove + mark pop
    let cx=0, cy=0, cnt=0;
    removeIdx.forEach(i=>{
      const el = CELL_ELEMENTS[i] && CELL_ELEMENTS[i].button;
      if(el){ const rc = el.getBoundingClientRect(); cx+=rc.left+rc.width/2; cy+=rc.top+rc.height/2; cnt++; el.classList.add('pop'); }
      state.board[i] = null;
    });
    if(cnt>0) burst(cx/cnt, cy/cnt, Math.min(8, 4+cnt));

    // after pop -> gravity & refill
    setTimeout(()=>{
      try{
        const cols = [];
        for(let c=0;c<WIDTH;c++){
          const col=[];
          for(let r=HEIGHT-1;r>=0;r--){
            const idx=r*WIDTH+c;
            if(state.board[idx]) col.push(state.board[idx]);
          }
          cols.push(col);
        }
        const newBoard = new Array(SIZE).fill(null);
        const dropMap = {};
        const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
        const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
        for(let c=0;c<WIDTH;c++){
          const col = cols[c];
          while(col.length < HEIGHT) col.push(randTile()); // NEW tiles created only here
          for(let r=HEIGHT-1,i=0;r>=0;r--,i++){
            const tile = col[i];
            newBoard[r*WIDTH+c] = tile;
            if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
          }
        }
        // assign specials -> bomb image
        Object.keys(specialMap).forEach(k=>{
          const idx = Number(k);
          if(newBoard[idx]) newBoard[idx].src = IMAGE_BASE + 'bomb.jpg';
          else { const pos=newBoard.findIndex(x=>x); if(pos>=0) newBoard[pos].src = IMAGE_BASE + 'bomb.jpg'; }
        });

        state.board = newBoard;
        fitTiles(); renderFast(dropMap);
      }catch(e){ console.error('gravity/refill error', e); }
      setTimeout(()=> setTimeout(step, 200), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fall-dur')) || 320);
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 300);
  })();
}

/* ---------- Input: pointer drag to swap with animated movement ---------- */
function onPointerDown(e){
  if(locked) return;
  try{
    const el = e.currentTarget; el.setPointerCapture && el.setPointerCapture(e.pointerId);
    dragging=true; pointerId=e.pointerId; lastIndex = Number(el.dataset.index);
    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);
  }catch(err){ console.warn('onPointerDown error', err); }
}

function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  try{
    const target = document.elementFromPoint(e.clientX, e.clientY);
    if(!target) return;
    const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
    if(!cell) return;
    const idx = Number(cell.dataset.index);
    if(Number.isNaN(idx)) return;
    if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
      // animate swap smoothly
      animatedSwap(lastIndex, idx).then(success=>{
        // decrement moves only if swap executed (even if reverted)
        state.moves = Math.max(0, state.moves-1);
        updateHUD();
        const matches = findMatches(state.board);
        if(matches.length>0) resolveChain();
        else {
          // if no matches, revert animation then revert board (animatedSwap handles revert if needed)
        }
      }).catch(err=>console.warn(err));
      lastIndex = idx;
    }
  }catch(err){ console.warn('onPointerMove error', err); }
}

function onPointerUp(e){
  dragging=false; pointerId=null; lastIndex=null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}

function isAdjacent(a,b){
  if(a==null||b==null) return false;
  const r1=Math.floor(a/WIDTH), c1=a%WIDTH, r2=Math.floor(b/WIDTH), c2=b%WIDTH;
  return Math.abs(r1-r2)+Math.abs(c1-c2)===1;
}

/* Animated swap:
   - visually translate the two .cell elements along delta
   - after animation, swap state.board objects
   - if no match, we revert visually and state back
*/
function animatedSwap(i,j){
  return new Promise(resolve=>{
    // get elements
    const A = CELL_ELEMENTS[i].button;
    const B = CELL_ELEMENTS[j].button;
    if(!A||!B){ resolve(false); return; }

    const rectA = A.getBoundingClientRect();
    const rectB = B.getBoundingClientRect();
    const dx = rectB.left - rectA.left;
    const dy = rectB.top - rectA.top;

    // apply transforms
    A.classList.add('moving'); B.classList.add('moving');
    A.style.transform = `translate(${dx}px, ${dy}px)`;
    B.style.transform = `translate(${-dx}px, ${-dy}px)`;

    // after animation - swap state
    setTimeout(()=>{
      // clear transforms
      A.style.transition = '';
      B.style.transition = '';
      A.style.transform = '';
      B.style.transform = '';

      // swap data in state (swap tile objects)
      swapStateTiles(i,j);
      renderFast(); // render positions from state (no random creation)

      // done
      resolve(true);
    }, 220);
  });
}

/* swap in state (no new tiles) */
function swapStateTiles(i,j){
  [state.board[i], state.board[j]] = [state.board[j], state.board[i]];
}

/* ---------- Place Bomb utility ---------- */
document.getElementById('placeBomb').addEventListener('click', ()=>{
  if(locked) return;
  const valid = state.board.map((t,i)=> t ? i : -1).filter(i=> i>=0);
  if(valid.length === 0) return;
  const idx = valid[Math.floor(Math.random()*valid.length)];
  state.board[idx] = makeTile(IMAGE_BASE + 'bomb.jpg');
  state.board[idx].power = {type:'bomb'};
  renderFast();
  setTimeout(()=> {
    const removed = new Set();
    const r0 = Math.floor(idx/WIDTH), c0 = idx%WIDTH;
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      const nr=r0+dr, nc=c0+dc;
      if(nr>=0&&nr<HEIGHT&&nc>=0&&nc<WIDTH) removed.add(nr*WIDTH+nc);
    }
    Array.from(removed).forEach(i=>{ const el = CELL_ELEMENTS[i] && CELL_ELEMENTS[i].button; if(el) el.classList.add('pop'); state.board[i]=null; });
    state.score += removed.size * 12; updateHUD();
    setTimeout(()=> resolveChain(), 220);
  }, 260);
});

/* ---------- HUD & controls ---------- */
function updateHUD(){
  try{
    document.getElementById('score').textContent = state.score;
    document.getElementById('moves').textContent = state.moves;
  }catch(e){}
}

document.getElementById('restart').addEventListener('click', ()=> initBoardFast());
document.getElementById('shuffle').addEventListener('click', ()=>{
  const tmp = state.board.slice();
  for(let i=tmp.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [tmp[i], tmp[j]]=[tmp[j], tmp[i]]; }
  state.board = tmp;
  renderFast();
});

/* ---------- Init board (create initial random tiles, ensure no immediate matches) ---------- */
function initBoardFast(){
  state.nextId = 1;
  state.board = new Array(SIZE).fill(null).map(()=>randTile());
  // avoid starting matches
  let tries=0;
  while(findMatches(state.board).length>0 && tries++ < 800){
    state.board = new Array(SIZE).fill(null).map(()=>randTile());
  }
  state.score = 0; state.moves = 40; state.combo = 1;
  fitTiles(); renderFast();
}

/* ---------- Resize debounce ---------- */
let resizeTO;
window.addEventListener('resize', ()=>{ clearTimeout(resizeTO); resizeTO = setTimeout(()=>{ fitTiles(); renderFast(); }, 120); });

/* ---------- Overlays: Start & Shop ---------- */
document.getElementById('homeStart').addEventListener('click', ()=>{
  // hide home overlay and start game
  homeOverlay.style.display='none';
  // if not initialized yet, create board
  if(!state.board || state.board.length!==SIZE) initBoardFast();
});
document.getElementById('homeShop').addEventListener('click', ()=>{
  shopOverlay.style.display='flex';
});
document.getElementById('closeShop').addEventListener('click', ()=>{
  shopOverlay.style.display='none';
});
document.getElementById('homeSettings').addEventListener('click', ()=>{
  alert('Settings placeholder ‚Äî add options you want.');
});

/* ---------- Preload and start sequence ---------- */
(async function start(){
  await detectImages();
  pool.forEach(u=>{ const i=new Image(); i.src=u; });
  createCellsOnce();
  // keep overlay visible until user presses Start
  // but init board now so Start shows immediate grid when hidden
  initBoardFast();
})();

/* expose debug */
window._cm = { state, renderFast, initBoardFast, fitTiles, pool };

</script>
</body>
</html>
