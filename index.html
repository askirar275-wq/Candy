<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Candy Match ‚Äî Fixed (no-change-on-move)</title>
<style>
:root{
  --cols:8;
  --rows:8;
  --gap:6px;       /* tighter gap you asked */
  --tile:66px;     /* will be adjusted by JS for responsiveness */
  --accent:#ff4d9e;
  --pop-dur:260ms;
  --fall-dur:320ms;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
body{overflow:auto}
.stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:14px}
.card{width:100%;max-width:820px;padding:14px;border-radius:14px;background:#fff;box-shadow:0 20px 60px rgba(20,20,50,.06);display:flex;flex-direction:column;gap:12px;overflow:visible}
header{display:flex;align-items:center;justify-content:space-between;gap:12px}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:28px}
.meta{font-size:13px;color:#666}
.hud{display:flex;gap:12px;align-items:center}
.hud .pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:8px 14px;border-radius:999px;box-shadow:0 10px 28px rgba(20,20,60,0.04);text-align:center;font-weight:800}

.content{display:flex;flex-direction:column;gap:10px}
.grid-wrap{width:100%;border-radius:12px;background:linear-gradient(180deg,#fff,#fff7fb);padding:12px;display:flex;align-items:center;justify-content:center;position:relative;box-shadow:inset 0 8px 30px rgba(250,240,250,0.4)}
.grid{
  display:grid;
  gap:var(--gap);
  grid-template-columns:repeat(var(--cols), var(--tile));
  grid-auto-rows:var(--tile);
  justify-content:center;
  align-content:center;
  touch-action:none;
  user-select:none;
  padding:6px;
  background:rgba(255,255,255,0.6);
  border-radius:12px;
}
.cell{
  width:var(--tile);
  height:var(--tile);
  border-radius:14px;
  display:flex;
  align-items:center;
  justify-content:center;
  background:linear-gradient(180deg,#fff,#fffefc);
  box-shadow:0 8px 18px rgba(10,10,30,0.05);
  cursor:grab;
  position:relative;
  overflow:visible;
  border:1px solid rgba(0,0,0,0.03);
  transition:transform .12s ease, opacity .12s ease;
  padding:0;
}
.cell img{ width:82%; height:82%; object-fit:contain; pointer-events:none; display:block; }
.cell.pop{animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
@keyframes pop{0%{transform:scale(1);opacity:1}45%{transform:scale(1.35)}100%{transform:scale(0);opacity:0}}

.controls{display:flex;gap:12px;justify-content:center;padding:8px 6px;flex-wrap:wrap}
.btn{padding:12px 18px;border-radius:14px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}

.footer{display:flex;align-items:center;justify-content:space-between;padding:8px 6px;gap:12px}
.note{font-size:13px;color:#666}

@media(max-width:720px){
  :root{ --tile:52px; --gap:5px; }
  .card{padding:10px}
  .grid-wrap{padding:10px}
}
</style>
</head>
<body>
  <div class="stage">
    <div class="card" id="card">
      <header>
        <div class="brand">
          <div class="logo">üç≠</div>
          <div>
            <div style="font-weight:900;font-size:18px">Candy Match ‚Äî Fixed</div>
            <div class="meta">Images from GitHub images/ folder</div>
          </div>
        </div>
        <div class="hud">
          <div class="pill"><small>Score</small><div id="score">0</div></div>
          <div class="pill"><small>Moves</small><div id="moves">40</div></div>
        </div>
      </header>

      <div class="content">
        <div class="grid-wrap">
          <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
        </div>

        <div class="controls">
          <button id="restart" class="btn primary">Restart</button>
          <button id="shuffle" class="btn">Shuffle</button>
        </div>
      </div>

      <div class="footer">
        <div class="note">Images taken from <code>images/</code> ‚Äî put your candy images there</div>
        <div id="debug" class="note" aria-hidden></div>
      </div>
    </div>
  </div>

<script>
/* Simple fixed candy logic:
   - images loaded from images/ pool (change IMAGE_NAMES if needed)
   - swap only swaps existing tile objects (no randomization in render)
   - new tiles are created only by gravity/refill after matches
*/

const WIDTH = 8, HEIGHT = 8, SIZE = WIDTH * HEIGHT;
const IMAGE_BASE = 'images/';
const IMAGE_NAMES = [
  'candy1.png','candy2.png','candy3.png','candy4.png','candy5.png',
  'candy6.png','candy7.png','candy8.png','candy9.png','candy10.png'
]; // add your filenames present in repo/images/

const grid = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const debugEl = document.getElementById('debug');

let pool = []; // urls that actually load
let state = { nextId:1, board: new Array(SIZE).fill(null), score:0, moves:40, combo:1 };
let CELL_ELEMENTS = [];
let dragging=false, pointerId=null, lastIndex=null, locked=false;

/* load images present in images/ folder (best-effort) */
function tryLoad(url){
  return new Promise(res=>{
    const i = new Image();
    i.onload = ()=> res({ok:true, url});
    i.onerror = ()=> res({ok:false, url});
    i.src = url;
  });
}
async function detectPool(){
  const checks = await Promise.all(IMAGE_NAMES.map(n=>tryLoad(IMAGE_BASE + n)));
  pool = checks.filter(c=>c.ok).map(c=>c.url);
  if(pool.length === 0){
    // fallback placeholder (svg data uri)
    pool = ['data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="64" height="64"><rect width="100%" height="100%" fill="%23eee"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="%23222" font-size="12">üç≠</text></svg>'];
  }
  debugEl.textContent = `Images: ${pool.length}`;
}

/* responsive tile size calculation */
function fitTiles(){
  try{
    const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 6;
    const wrap = document.querySelector('.grid-wrap').getBoundingClientRect();
    const card = document.getElementById('card').getBoundingClientRect();
    const availW = Math.min(wrap.width - 12, card.width - 30);
    const availH = Math.max(220, window.innerHeight * 0.55);
    const candidateW = Math.floor((availW - gap*(WIDTH-1))/WIDTH);
    const candidateH = Math.floor((availH - gap*(HEIGHT-1))/HEIGHT);
    let tile = Math.max(18, Math.min(candidateW, candidateH));
    document.documentElement.style.setProperty('--tile', tile + 'px');
  }catch(e){ console.warn('fitTiles', e); }
}

/* create DOM cells once */
function createCellsOnce(){
  grid.innerHTML = '';
  CELL_ELEMENTS = [];
  grid.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    const img = document.createElement('img');
    img.alt = 'candy';
    img.draggable = false;
    img.dataset.src = '';
    btn.appendChild(img);
    btn.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(btn);
    CELL_ELEMENTS.push({btn, img});
  }
}

/* render: show existing tiles only; DO NOT create new random tiles here */
function renderBoard(dropMap){
  if(!CELL_ELEMENTS || CELL_ELEMENTS.length !== SIZE) createCellsOnce();
  for(let i=0;i<SIZE;i++){
    const entry = CELL_ELEMENTS[i];
    const btn = entry.btn;
    const img = entry.img;
    // remove stray text nodes
    btn.childNodes.forEach(n=>{ if(n.nodeType === 3) n.remove(); });
    const tile = state.board[i];
    if(tile){
      const src = tile.src || '';
      if(img.dataset.src !== src){
        img.dataset.src = src;
        img.src = src;
      }
      btn.style.visibility = 'visible';
    } else {
      // empty slot: hide image (will be filled in gravity/refill)
      img.dataset.src = '';
      img.src = '';
      btn.style.visibility = 'hidden';
    }
    btn.style.transition = '';
    btn.style.transform = '';
    if(dropMap && tile && dropMap[tile.id]){
      btn.style.transform = `translateY(${dropMap[tile.id]})`;
      requestAnimationFrame(()=> requestAnimationFrame(()=>{
        btn.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`;
        btn.style.transform = 'translateY(0)';
      }));
    }
    btn.classList.remove('pop');
  }
  updateHUD();
}

/* create new tile object (only called in refill) */
function makeTile(src){
  return { id: state.nextId++, src: src || pool[Math.floor(Math.random()*pool.length)], power: null };
}

/* match detection by src equality */
function findMatches(board){
  const matches = [];
  // horizontal
  for(let r=0;r<HEIGHT;r++){
    let run=[r*WIDTH];
    for(let c=1;c<WIDTH;c++){
      const p = r*WIDTH+c-1, i = r*WIDTH+c;
      if(board[i] && board[p] && board[i].src === board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // vertical
  for(let c=0;c<WIDTH;c++){
    let run=[c];
    for(let r=1;r<HEIGHT;r++){
      const p = (r-1)*WIDTH + c, i = r*WIDTH + c;
      if(board[i] && board[p] && board[i].src === board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* small particle burst */
function burst(x,y,amount=8){
  try{
    const rect = grid.getBoundingClientRect();
    const ox = x - rect.left, oy = y - rect.top;
    amount = Math.min(8, amount);
    for(let i=0;i<amount;i++){
      const p = document.createElement('div');
      p.style.position='absolute';
      p.style.left = ox + 'px';
      p.style.top = oy + 'px';
      const s = 6 + Math.random()*8;
      p.style.width = p.style.height = s + 'px';
      p.style.borderRadius = '50%';
      p.style.background = `rgba(255,90,140,${0.35+Math.random()*0.5})`;
      p.style.pointerEvents = 'none';
      grid.parentElement.appendChild(p);
      const angle = Math.random()*Math.PI*2;
      const dist = 18 + Math.random()*40;
      const nx = Math.cos(angle)*dist, ny = Math.sin(angle)*dist;
      p.animate([{transform:'translate(-50%,-50%) scale(1)', opacity:1},{transform:`translate(-50%,-50%) translate(${nx}px,${ny}px) scale(.3)`, opacity:0}], {duration:450+Math.random()*250, easing:'cubic-bezier(.2,.8,.2,1)'});
      setTimeout(()=>p.remove(),900);
    }
  }catch(e){ console.warn(e); }
}

/* resolve chain: find matches, remove, gravity, refill (new tiles only here) */
function resolveChain(){
  if(locked) return;
  locked = true;
  state.combo = 1;
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length === 0){ locked = false; updateHUD(); return; }
    // compute unique positions to remove
    const removeSet = new Set();
    matches.forEach(run => run.forEach(i=>removeSet.add(i)));
    const removeIdx = Array.from(removeSet).sort((a,b)=>a-b);
    const removedCount = removeIdx.length;
    state.score += removedCount * 10 * state.combo;
    state.combo++;
    updateHUD();

    // animate pop and set null
    let cx=0, cy=0, cnt=0;
    removeIdx.forEach(i=>{
      const el = CELL_ELEMENTS[i] && CELL_ELEMENTS[i].btn;
      if(el){ const rc = el.getBoundingClientRect(); cx += rc.left + rc.width/2; cy += rc.top + rc.height/2; cnt++; el.classList.add('pop'); }
      state.board[i] = null;
    });
    if(cnt>0) burst(cx/cnt, cy/cnt, Math.min(8, 4+cnt));

    // after pop animation, gravity & refill
    setTimeout(()=>{
      try{
        const cols = [];
        for(let c=0;c<WIDTH;c++){
          const col = [];
          for(let r=HEIGHT-1;r>=0;r--){
            const idx = r*WIDTH + c;
            if(state.board[idx]) col.push(state.board[idx]);
          }
          cols.push(col);
        }
        const newBoard = new Array(SIZE).fill(null);
        const dropMap = {};
        const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
        const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
        for(let c=0;c<WIDTH;c++){
          const col = cols[c];
          while(col.length < HEIGHT) col.push(makeTile()); // NEW tiles created only here
          for(let r=HEIGHT-1,i=0;r>=0;r--,i++){
            const tile = col[i];
            newBoard[r*WIDTH+c] = tile;
            if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
          }
        }
        state.board = newBoard;
        fitTiles();
        renderBoard(dropMap);
      }catch(e){ console.error('gravity error', e); }
      // continue chain if new matches
      setTimeout(()=> setTimeout(step, 200), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fall-dur')) || 320);
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 260);
  })();
}

/* input handlers (pointer-based drag & swap) */
function onPointerDown(e){
  if(locked) return;
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true;
  pointerId = e.pointerId;
  lastIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
    // swap tile objects (no randomization)
    const i1 = lastIndex, i2 = idx;
    [state.board[i1], state.board[i2]] = [state.board[i2], state.board[i1]];
    renderBoard(); // show swapped tiles
    state.moves = Math.max(0, state.moves - 1);
    updateHUD();
    const matches = findMatches(state.board);
    if(matches.length > 0){
      resolveChain();
    } else {
      // revert if no match
      setTimeout(()=>{
        [state.board[i1], state.board[i2]] = [state.board[i2], state.board[i1]];
        renderBoard();
      }, 280);
    }
    lastIndex = idx;
  }
}
function onPointerUp(e){
  dragging = false;
  pointerId = null;
  lastIndex = null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){
  if(a==null || b==null) return false;
  const r1 = Math.floor(a/WIDTH), c1 = a%WIDTH, r2 = Math.floor(b/WIDTH), c2 = b%WIDTH;
  return Math.abs(r1-r2) + Math.abs(c1-c2) === 1;
}

/* controls */
document.getElementById('restart').addEventListener('click', initGame);
document.getElementById('shuffle').addEventListener('click', ()=>{
  // shuffle existing tiles (preserve tile objects)
  const tmp = state.board.slice();
  for(let i=tmp.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [tmp[i], tmp[j]] = [tmp[j], tmp[i]];
  }
  state.board = tmp;
  renderBoard();
});

/* init board: fill only here with random tiles, but make sure no initial matches */
function initGame(){
  state.nextId = 1;
  state.score = 0;
  state.moves = 40;
  state.combo = 1;
  // create initial board
  state.board = new Array(SIZE).fill(null).map(()=> makeTile());
  // avoid starting matches
  let tries = 0;
  while(findMatches(state.board).length > 0 && tries++ < 600){
    state.board = new Array(SIZE).fill(null).map(()=> makeTile());
  }
  fitTiles();
  renderBoard();
  updateHUD();
}

/* HUD */
function updateHUD(){
  scoreEl.textContent = state.score;
  movesEl.textContent = state.moves;
}

/* resize handling */
let resizeTO;
window.addEventListener('resize', ()=>{ clearTimeout(resizeTO); resizeTO = setTimeout(()=>{ fitTiles(); renderBoard(); }, 120); });

/* start */
(async function start(){
  await detectPool();
  pool.forEach(u=>{ const i=new Image(); i.src = u; }); // preload
  createCellsOnce();
  initGame();
})();

/* expose debug */
window._cm = { state, pool, renderBoard, initGame, fitTiles };

</script>
</body>
</html>
