<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Candy / Fruit Match ‚Äî Real images from GitHub</title>
<style>
  :root{ --cols:8; --gap:4px; --tile:64px; --accent:#ff4d9e; --pop:300ms; --fall:320ms; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
  .stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:16px}
  .card{width:100%;max-width:980px;padding:14px;border-radius:14px;background:#fff;box-shadow:0 28px 80px rgba(20,20,50,.06);display:flex;flex-direction:column;gap:12px;overflow:visible}
  header{display:flex;align-items:center;justify-content:space-between}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:56px;height:56px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:28px}
  .hud{display:flex;gap:12px;align-items:center}
  .pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:8px 14px;border-radius:40px;font-weight:800}
  .content{display:flex;flex-direction:column;gap:8px}
  .grid-wrap{width:100%;max-width:860px;border-radius:12px;background:linear-gradient(180deg,#fff,#fff7fb);padding:12px;display:flex;align-items:center;justify-content:center;position:relative;box-shadow:inset 0 8px 30px rgba(250,240,250,0.4);overflow:auto}
  .grid{display:grid;gap:var(--gap);grid-template-columns:repeat(var(--cols), var(--tile));grid-auto-rows:var(--tile);justify-content:center;align-content:center}
  .cell{width:var(--tile);height:var(--tile);border-radius:12px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#fff,#fffefc);box-shadow:0 8px 18px rgba(10,10,30,0.05);cursor:grab;position:relative;overflow:visible;padding:0;border:1px solid rgba(0,0,0,0.04)}
  .cell img{width:86%;height:86%;object-fit:contain;pointer-events:none;display:block}
  .cell.pop{animation:pop var(--pop) cubic-bezier(.2,.9,.2,1) forwards}
  @keyframes pop{0%{transform:scale(1);opacity:1}45%{transform:scale(1.4)}100%{transform:scale(0);opacity:0}}
  .controls{display:flex;gap:10px;justify-content:center;padding:8px 6px}
  .btn{padding:10px 14px;border-radius:12px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
  .btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
  footer{display:flex;align-items:center;justify-content:space-between;padding:8px 6px}
  .small{font-size:13px;color:#666}
  @media(max-width:720px){:root{--tile:52px;--gap:3px} .card{padding:10px}}
</style>
</head>
<body>
  <div class="stage">
    <div class="card" id="card">
      <header>
        <div class="brand">
          <div class="logo">üç≠</div>
          <div>
            <div style="font-weight:900;font-size:18px">Candy / Fruit Match</div>
            <div class="small">GitHub images auto-detected</div>
          </div>
        </div>
        <div class="hud">
          <div class="pill">Score <div id="score">0</div></div>
          <div class="pill">Moves <div id="moves">40</div></div>
        </div>
      </header>

      <div class="content">
        <div class="grid-wrap">
          <div id="grid" class="grid" role="grid" aria-label="game-grid"></div>
        </div>

        <div class="controls">
          <button id="restart" class="btn primary">Restart</button>
          <button id="shuffle" class="btn">Shuffle</button>
          <button id="placeBomb" class="btn">Place Bomb</button>
        </div>
      </div>

      <footer>
        <div class="small">Images loaded from <span id="imgCount">0</span> files</div>
        <div class="small">Made with ‚ô•</div>
      </footer>
    </div>
  </div>

<script>
/* Auto-detect images from repo's images/ folder (GitHub Pages) and use them in the game.
   Behavior:
   - Tries a list of common and numbered candidate filenames inside "images/" (relative path).
   - Loads those that succeed (onload).
   - If at least 6 images found, use them; else fallback to emoji set.
*/

const WIDTH = 8, HEIGHT = 8, SIZE = WIDTH*HEIGHT;
const GRID = document.getElementById('grid');
const IMGCOUNT = document.getElementById('imgCount');

let state = { nextId:1, board:[], score:0, moves:40, combo:1 };
let cells = [];
let lock = false;

/* Candidates ‚Äî common names + numbered patterns (covers typical user uploads) */
const CANDIDATES = [
  // common names
  'apple.png','banana.png','orange.png','grape.png','watermelon.png','strawberry.png','pineapple.png','cherry.png',
  'donut.png','lollipop.png','candy1.png','candy2.png','candy3.png','candy4.png','candy5.png','candy6.png',
  'candy7.png','candy8.png','candy9.png','candy10.png','candy11.png','candy12.png',
  // jpg variants
  'apple.jpg','banana.jpg','donut.jpg','bomb.jpg','bomb.png'
];
// also try numbered 1..20
for(let i=1;i<=20;i++) CANDIDATES.push(`candy${i}.png`);

const IMAGE_BASE = 'images/'; // relative path on your GitHub Pages: /Candy/images/...
const loadedImages = []; // will be array of urls

function tryLoadSingle(url, timeout=1200){
  return new Promise((res)=>{
    const img = new Image();
    let done = false;
    const t = setTimeout(()=>{ if(!done){ done=true; res({ok:false,url}); img.src=''; } }, timeout);
    img.onload = ()=>{ if(!done){ done=true; clearTimeout(t); res({ok:true,url}); } };
    img.onerror = ()=>{ if(!done){ done=true; clearTimeout(t); res({ok:false,url}); } };
    img.src = url;
  });
}

async function detectImages(){
  // try candidates in parallel but stop after enough found
  const tries = CANDIDATES.map(n => IMAGE_BASE + n);
  const results = await Promise.all(tries.map(u=> tryLoadSingle(u)));
  results.forEach(r=>{
    if(r.ok) loadedImages.push(r.url);
  });

  // If still too few, also try raw github raw path fallback using location origin
  if(loadedImages.length < 6){
    // attempt a raw.githubusercontent pattern using repository known base if page hosted under GitHub Pages
    // Try using same-origin absolute path (it will resolve if images exist on GitHub Pages)
    const maybeBase = window.location.origin + window.location.pathname; // e.g. https://username.github.io/Candy/
    const extra = [];
    for(let i=1;i<=20;i++) extra.push(maybeBase + 'images/candy' + i + '.png');
    const extraResults = await Promise.all(extra.map(u=> tryLoadSingle(u)));
    extraResults.forEach(r=>{ if(r.ok) loadedImages.push(r.url); });
  }

  // dedupe and limit
  const uniq = Array.from(new Set(loadedImages));
  // if still none, fallback to emojis
  IMGCOUNT.textContent = uniq.length;
  return uniq;
}

/* fallback emoji set (if no images found) */
const EMOJI_POOL = ['üç≠','üç¨','üç´','üç©','üç™','üç°','üç∞','üçß','üçØ','üçé','üçå','üçá'];

function makeTile(src){
  return { id: state.nextId++, src, power:null };
}

function randTileFromPool(pool){
  const s = pool[Math.floor(Math.random()*pool.length)];
  return makeTile(s);
}

/* Build cells once */
function createGridCells(){
  GRID.innerHTML = '';
  cells = [];
  GRID.style.setProperty('--cols', WIDTH);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    const img = document.createElement('img');
    // img.src set in render
    btn.appendChild(img);
    btn.addEventListener('pointerdown', onPointerDown);
    GRID.appendChild(btn);
    cells.push({btn,img});
  }
}

/* Render */
function render(dropMap){
  for(let i=0;i<SIZE;i++) if(!state.board[i]) state.board[i] = randTileFromPool(pool);
  for(let i=0;i<SIZE;i++){
    const tile = state.board[i];
    const {btn,img} = cells[i];
    if(tile.src && tile.src.startsWith('data:') || tile.src.startsWith('http') || tile.src.includes('/images/')){
      // real image URL
      if(img.getAttribute('src') !== tile.src) img.src = tile.src;
      img.style.display = 'block';
      img.alt = 'candy';
    } else {
      // emoji fallback: show emoji as text (remove img)
      img.style.display = 'none';
      btn.textContent = tile.src;
    }
    btn.classList.remove('pop');
    if(dropMap && dropMap[tile.id]){
      btn.style.transform = `translateY(${dropMap[tile.id]})`;
      requestAnimationFrame(()=> requestAnimationFrame(()=> { btn.style.transition = `transform var(--fall) cubic-bezier(.2,.8,.2,1)`; btn.style.transform = 'translateY(0)'; }));
    } else btn.style.transform = '';
  }
  updateHUD();
}

/* match detection uses src equality (URL or emoji text) */
function findMatches(){
  const matches=[];
  // horizontal
  for(let r=0;r<HEIGHT;r++){
    let run=[r*WIDTH];
    for(let c=1;c<WIDTH;c++){
      const p=r*WIDTH+c-1, i=r*WIDTH+c;
      if(state.board[i] && state.board[p] && state.board[i].src === state.board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // vertical
  for(let c=0;c<WIDTH;c++){
    let run=[c];
    for(let r=1;r<HEIGHT;r++){
      const p=(r-1)*WIDTH+c, i=r*WIDTH+c;
      if(state.board[i] && state.board[p] && state.board[i].src === state.board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}

/* resolve chain (pop -> gravity -> refill) */
function resolveChain(){
  if(lock) return;
  lock = true; state.combo = 1;
  (function step(){
    const matches = findMatches();
    if(matches.length === 0){ lock=false; updateHUD(); return; }
    // collect unique indices
    const removeSet = new Set();
    matches.forEach(run=>run.forEach(idx=>removeSet.add(idx)));
    const removeIdx = Array.from(removeSet).sort((a,b)=>a-b);
    const removedCount = removeIdx.length;
    state.score += removedCount * 10 * state.combo;
    state.combo++;
    updateHUD();
    // animate pop
    let cx=0, cy=0, cnt=0;
    removeIdx.forEach(i=>{
      const el = cells[i].btn;
      if(el){ const rc = el.getBoundingClientRect(); cx+=rc.left+rc.width/2; cy+=rc.top+rc.height/2; cnt++; el.classList.add('pop'); }
      state.board[i] = null;
    });
    setTimeout(()=>{
      // gravity
      const cols=[];
      for(let c=0;c<WIDTH;c++){
        const col=[];
        for(let r=HEIGHT-1;r>=0;r--){
          const idx = r*WIDTH + c;
          if(state.board[idx]) col.push(state.board[idx]);
        }
        cols.push(col);
      }
      const newBoard = new Array(SIZE).fill(null);
      const dropMap = {};
      const tilePx = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--tile')) || 64;
      const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
      for(let c=0;c<WIDTH;c++){
        const col = cols[c];
        while(col.length < HEIGHT) col.push(randTileFromPool(pool));
        for(let r=HEIGHT-1,i=0;r>=0;r--,i++){
          const tile = col[i];
          newBoard[r*WIDTH+c] = tile;
          if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
        }
      }
      state.board = newBoard;
      render(dropMap);
      setTimeout(()=> setTimeout(step, 260), 320);
    }, 360);
  })();
}

/* input (pointer) handlers: implement simple drag-to-swap */
let dragging=false, pointerId=null, lastIndex=null;
function onPointerDown(e){
  if(lock) return;
  const el = e.currentTarget; el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true; pointerId = e.pointerId; lastIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(lastIndex, idx) && idx !== lastIndex){
    swapIndices(lastIndex, idx);
    render();
    state.moves = Math.max(0, state.moves-1);
    updateHUD();
    const matches = findMatches();
    if(matches.length>0) resolveChain();
    else setTimeout(()=>{ swapIndices(lastIndex, idx); render(); }, 180);
    lastIndex = idx;
  }
}
function onPointerUp(e){
  dragging=false; pointerId=null; lastIndex=null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){ if(a==null||b==null) return false; const r1=Math.floor(a/WIDTH), c1=a%WIDTH, r2=Math.floor(b/WIDTH), c2=b%WIDTH; return Math.abs(r1-r2)+Math.abs(c1-c2)===1; }
function swapIndices(i,j){ [state.board[i], state.board[j]] = [state.board[j], state.board[i]]; }

/* HUD & helpers */
function updateHUD(){ document.getElementById('score').textContent = state.score; document.getElementById('moves').textContent = state.moves; document.getElementById('imgCount').textContent = pool.length; }

function shuffleBoard(){ state.board = state.board.sort(()=>Math.random()-0.5); render(); }

function placeBomb(){ // convert random tile into bomb-image if available
  const idx = Math.floor(Math.random()*SIZE);
  state.board[idx] = makeTile(pool[0] || poolFallback[0]);
  state.board[idx].power = {type:'bomb'};
  render();
  setTimeout(()=> {
    // remove neighbours
    const r0 = Math.floor(idx / WIDTH), c0 = idx % WIDTH;
    const removed = [];
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      const nr=r0+dr, nc=c0+dc;
      if(nr>=0 && nr<HEIGHT && nc>=0 && nc<WIDTH) removed.push(nr*WIDTH + nc);
    }
    removed.forEach(i=>{ const el = cells[i].btn; if(el) el.classList.add('pop'); state.board[i]=null; });
    setTimeout(()=> resolveChain(), 220);
  }, 260);
}

/* pool: will be filled with loaded images or emojis fallback */
let pool = [];
const poolFallback = EMOJI_POOL;

/* init sequence */
async function init(){
  createGridCells();
  const found = await detectImages();
  if(found.length >= 6){
    pool = found;
  } else {
    // not enough real images -> fallback to emojis
    pool = poolFallback;
  }
  // create initial board
  state.nextId = 1;
  state.board = new Array(SIZE).fill(null).map(()=> randTileFromPool(pool) );
  render();
  updateHUD();
}

/* attach controls */
document.getElementById('restart').addEventListener('click', ()=> init());
document.getElementById('shuffle').addEventListener('click', ()=> shuffleBoard());
document.getElementById('placeBomb').addEventListener('click', ()=> placeBomb());

/* start */
init();

/* expose debug */
window._game = { state, pool, render, resolveChain };

</script>
</body>
</html>
