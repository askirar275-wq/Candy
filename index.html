<!doctype html>
<html lang="hi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Candy Crush ‚Äî Smooth Clone (Demo)</title>
<style>
:root{
  --cols:8; --rows:8;
  --gap:6px;
  --tile:66px; /* JS will fit */
  --accent:#ff4d9e;
  --pop-dur:360ms;
  --fall-dur:360ms;
  --swap-dur:200ms;
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{height:100%;margin:0;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,#fff9fc,#f2f7ff);color:#222}
.stage{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:12px}
.card{
  width:100%;max-width:980px;height:calc(100vh - 24px);padding:14px;border-radius:14px;background:#fff;
  box-shadow:0 28px 80px rgba(20,20,50,.06);
  display:flex;flex-direction:column;gap:12px;
  overflow:hidden;
}
/* header */
header{display:flex;align-items:center;justify-content:space-between}
.brand{display:flex;gap:12px;align-items:center}
.logo{width:52px;height:52px;border-radius:12px;background:linear-gradient(135deg,#fff0f6,#ffeef8);display:flex;align-items:center;justify-content:center;font-size:26px}
.hud{display:flex;gap:8px;align-items:center}
.pill{background:linear-gradient(180deg,#fff,#fff7fb);padding:8px 12px;border-radius:999px;font-weight:800;display:flex;flex-direction:column;align-items:center}

/* grid area */
.content{display:flex;flex-direction:column;gap:10px;flex:1 1 auto;min-height:0}
.grid-area{flex:1 1 auto;display:flex;align-items:center;justify-content:center;padding:6px;min-height:0}
.grid-wrap{width:100%;max-width:880px;border-radius:14px;background:linear-gradient(180deg,#fff,#fff7fb);padding:10px;box-shadow:inset 0 8px 30px rgba(250,240,250,0.4);display:flex;align-items:center;justify-content:center;position:relative;overflow:hidden;max-height:calc(100vh - 240px)}
.grid{
  display:grid; gap:var(--gap);
  grid-template-columns:repeat(var(--cols), var(--tile));
  grid-auto-rows:var(--tile);
  touch-action:none; user-select:none; justify-content:center;align-content:center;
  position:relative;
}

/* cell */
.cell{
  width:var(--tile); height:var(--tile);
  border-radius:12px; background:linear-gradient(180deg,#fff,#fffefc);
  box-shadow:0 8px 18px rgba(10,10,30,0.05);
  display:flex;align-items:center;justify-content:center;cursor:grab;
  position:relative; overflow:visible; border:1px solid rgba(0,0,0,0.04);
  transform: translateZ(0);
  will-change: transform, opacity;
  padding:0;
}
.cell img{ width:78%; height:78%; object-fit:contain; pointer-events:none; display:block; user-select:none; }
.cell.pop{animation:pop var(--pop-dur) cubic-bezier(.2,.9,.2,1) forwards}
@keyframes pop{0%{transform:scale(1);opacity:1}40%{transform:scale(1.4)}100%{transform:scale(0);opacity:0}}

/* controls and footer */
.controls{display:flex;gap:10px;justify-content:center;padding:8px 6px}
.btn{padding:10px 14px;border-radius:12px;border:0;font-weight:800;background:#fff;cursor:pointer;box-shadow:0 10px 28px rgba(20,20,60,0.06)}
.btn.primary{background:linear-gradient(90deg,var(--accent),#ff9ac8);color:#fff}
.footer{display:flex;align-items:center;justify-content:space-between;padding:10px;gap:12px}
.progress{height:12px;width:220px;background:#eee;border-radius:999px;overflow:hidden}
.progress i{display:block;height:100%;width:0;background:linear-gradient(90deg,#ff9ac8,#ff6aa8);transition:width 320ms ease}

/* particles canvas full area inside grid-wrap */
#particleCanvas{position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none}

/* mobile */
@media(max-width:720px){
  :root{--tile:52px;--gap:4px}
  .card{height:auto}
  .grid-wrap{max-height:60vh}
}
</style>
</head>
<body>
  <div class="stage">
    <div class="card" id="card">
      <header>
        <div class="brand">
          <div class="logo">üç¨</div>
          <div>
            <div style="font-weight:900;font-size:18px">Candy Match ‚Äî Smooth</div>
            <div style="font-size:12px;color:#666">Swipe ‚Äî Match ‚Äî Pop</div>
          </div>
        </div>
        <div class="hud">
          <div class="pill"><small>Level</small><div id="level">1</div></div>
          <div class="pill"><small>Score</small><div id="score">0</div></div>
          <div class="pill"><small>Moves</small><div id="moves">40</div></div>
        </div>
      </header>

      <div class="content">
        <div class="grid-area">
          <div id="gridWrap" class="grid-wrap">
            <canvas id="particleCanvas"></canvas>
            <div id="grid" class="grid" role="grid" aria-label="Candy grid"></div>
          </div>
        </div>

        <div class="controls">
          <button id="restart" class="btn primary">Restart</button>
          <button id="shuffle" class="btn">Shuffle</button>
          <button id="bombBtn" class="btn">Place Bomb</button>
        </div>
      </div>

      <div class="footer">
        <div style="font-size:13px;color:#666">Images from GitHub: <span id="imgCount">0</span></div>
        <div style="display:flex;align-items:center;gap:12px">
          <div id="comboText" style="font-weight:900;color:var(--accent)">Combo √ó1</div>
          <div class="progress" aria-hidden><i id="progressBar"></i></div>
        </div>
      </div>
    </div>
  </div>

<script>
/*
 Advanced smooth Candy-Match clone
 - GPU transforms for swap/fall
 - requestAnimationFrame driven canvas particles
 - robust: uses images from images/ folder (update IMAGE_FILES)
 - mobile touch + pointer events
*/

/* ========== CONFIG ========== */
/* Update these filenames to match your GitHub images in images/ folder */
const IMAGE_FILES = [
  'images/candy1.png','images/candy2.png','images/candy3.png','images/candy4.png',
  'images/candy5.png','images/candy6.png','images/candy7.png','images/candy8.png',
  'images/candy9.png','images/candy10.png'
];
const BOMB_SRC = 'images/bomb.jpg'; // bomb image (optional)

const COLS = 8, ROWS = 8, SIZE = COLS * ROWS;
const grid = document.getElementById('grid');
const gridWrap = document.getElementById('gridWrap');
const particleCanvas = document.getElementById('particleCanvas');
const scoreEl = document.getElementById('score');
const movesEl = document.getElementById('moves');
const levelEl = document.getElementById('level');
const comboText = document.getElementById('comboText');
const progressBar = document.getElementById('progressBar');
const imgCountEl = document.getElementById('imgCount');

let state = { nextId:1, board:[], score:0, moves:40, combo:1, level:1 };
let cellEls = [];
let dragging=false, pointerId=null, startIndex=null;
let locked=false;
let pool = []; // loaded image URLs
let tilePx = 64;

/* particles system (canvas) */
const ctx = particleCanvas.getContext && particleCanvas.getContext('2d');
let particles = [];
function resizeCanvas(){
  const r = gridWrap.getBoundingClientRect();
  particleCanvas.width = Math.round(r.width * devicePixelRatio);
  particleCanvas.height = Math.round(r.height * devicePixelRatio);
  particleCanvas.style.width = r.width + 'px';
  particleCanvas.style.height = r.height + 'px';
  if(ctx) ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
}
function createParticle(x,y){
  particles.push({
    x, y,
    vx: (Math.random()-0.5)*6,
    vy: (Math.random()-1.5)*6,
    life: 40 + Math.random()*30,
    size: 4 + Math.random()*8,
    alpha:1,
    color:`rgba(${200+Math.floor(Math.random()*55)}, ${40+Math.floor(Math.random()*160)}, ${140+Math.floor(Math.random()*80)},`
  });
}
function tickParticles(){
  if(!ctx) return;
  ctx.clearRect(0,0,particleCanvas.width,particleCanvas.height);
  for(let i=particles.length-1;i>=0;i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.vy += 0.25;
    p.life -= 1;
    p.alpha = Math.max(0, p.life / 70);
    if(p.life<=0){ particles.splice(i,1); continue; }
    ctx.beginPath();
    ctx.fillStyle = p.color + p.alpha + ')';
    ctx.arc(p.x, p.y, p.size * (p.alpha+0.3), 0, Math.PI*2);
    ctx.fill();
  }
  requestAnimationFrame(tickParticles);
}
tickParticles();

/* ========== IMAGE LOADING ========== */
/* Try load images; if none found use emoji SVG fallback */
function probeImages(list){
  const checks = list.map(src => new Promise(res => {
    const img = new Image();
    img.onload = ()=> res({ok:true, src});
    img.onerror = ()=> res({ok:false, src});
    img.src = src;
  }));
  return Promise.all(checks).then(results => results.filter(r=>r.ok).map(r=>r.src));
}

/* fallback small svg data-URI candy (emoji) */
const FALLBACK_SVG = encodeURI(
  '<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128"><rect width="100%" height="100%" fill="%23fff"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="60">üç¨</text></svg>'
);
const FALLBACK_SRC = 'data:image/svg+xml;utf8,' + FALLBACK_SVG;

/* ========== BOARD + RENDER ========== */
function fitTiles(){
  const gap = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--gap')) || 6;
  const avail = gridWrap.getBoundingClientRect();
  const candidateH = Math.floor((avail.height - gap*(ROWS-1)) / ROWS);
  const candidateW = Math.floor((avail.width - gap*(COLS-1)) / COLS);
  let base = Math.max(22, Math.min(candidateH, candidateW));
  tilePx = Math.floor(base * 1.02);
  document.documentElement.style.setProperty('--tile', tilePx + 'px');
}

/* create DOM cells once */
function createCells(){
  grid.innerHTML = '';
  cellEls = [];
  grid.style.setProperty('--cols', COLS);
  for(let i=0;i<SIZE;i++){
    const btn = document.createElement('button');
    btn.className = 'cell';
    btn.dataset.index = i;
    const img = document.createElement('img');
    img.alt = 'candy';
    img.draggable = false;
    img.dataset.src = '';
    btn.appendChild(img);
    // pointer events
    btn.addEventListener('pointerdown', onPointerDown);
    grid.appendChild(btn);
    cellEls.push({btn, img});
  }
}

/* render board fast (only swap src & apply dropMap transforms) */
function render(dropMap){
  for(let i=0;i<SIZE;i++) if(!state.board[i]) state.board[i] = randTile();
  for(let i=0;i<SIZE;i++){
    const tile = state.board[i];
    const {btn,img} = cellEls[i];
    const src = tile.src || FALLBACK_SRC;
    if(img.dataset.src !== src){
      img.dataset.src = src;
      img.src = src;
    }
    btn.style.transition = '';
    btn.style.transform = '';
    if(dropMap && dropMap[tile.id]){
      btn.style.transform = `translateY(${dropMap[tile.id]})`;
      requestAnimationFrame(()=> requestAnimationFrame(()=> {
        btn.style.transition = `transform var(--fall-dur) cubic-bezier(.2,.8,.2,1)`;
        btn.style.transform = 'translateY(0)';
      }));
    }
    btn.classList.remove('pop');
  }
  updateHUD();
}

/* make tile object */
function makeTile(src){ return { id: state.nextId++, src: src || pool[Math.floor(Math.random()*pool.length)], power:null }; }
function randTile(){ return makeTile(); }

/* ========== MATCH LOGIC ========== */
function findMatches(board){
  const matches = [];
  // horizontal
  for(let r=0;r<ROWS;r++){
    let run=[r*COLS];
    for(let c=1;c<COLS;c++){
      const p = r*COLS + c -1, i = r*COLS + c;
      if(board[i] && board[p] && board[i].src === board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  // vertical
  for(let c=0;c<COLS;c++){
    let run=[c];
    for(let r=1;r<ROWS;r++){
      const p = (r-1)*COLS + c, i = r*COLS + c;
      if(board[i] && board[p] && board[i].src === board[p].src) run.push(i);
      else { if(run.length>=3) matches.push([...run]); run=[i]; }
    }
    if(run.length>=3) matches.push([...run]);
  }
  return matches;
}
function detectSpecials(matches){
  const map = {};
  matches.forEach(run=>{
    if(run.length>=5){ map[run[Math.floor(run.length/2)]] = {type:'color'}; }
    else if(run.length===4){ map[run[Math.floor(run.length/2)]] = {type:'stripe'}; }
  });
  return map;
}

/* ========== UI & HUD ========== */
function updateHUD(){
  scoreEl.textContent = state.score;
  movesEl.textContent = state.moves;
  levelEl.textContent = state.level;
  comboText.textContent = `Combo √ó${Math.max(1, state.combo-1)}`;
  progressBar.style.width = Math.min(100, Math.round(state.score / (2000 + (state.level-1)*500) * 100)) + '%';
}

/* ========== SWAP ANIMATION (smooth) ========== */
/* animate swap visually by translating two elements, then commit logical swap */
function swapAnimate(i, j){
  return new Promise(res=>{
    const a = cellEls[i].btn, b = cellEls[j].btn;
    const ar = a.getBoundingClientRect(), br = b.getBoundingClientRect();
    const dx = br.left - ar.left, dy = br.top - ar.top;
    // set will-change and translate
    a.style.transition = `transform var(--swap-dur) cubic-bezier(.2,.9,.2,1)`;
    b.style.transition = `transform var(--swap-dur) cubic-bezier(.2,.9,.2,1)`;
    a.style.transform = `translate(${dx}px, ${dy}px)`;
    b.style.transform = `translate(${-dx}px, ${-dy}px)`;
    // on end
    setTimeout(()=>{ a.style.transition=''; a.style.transform=''; b.style.transition=''; b.style.transform=''; res(); }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--swap-dur')) || 200);
  });
}

/* ========== CHAIN RESOLUTION (pop -> gravity -> refill) ========== */
function resolveChain(){
  if(locked) return;
  locked = true;
  state.combo = 1;
  (function step(){
    const matches = findMatches(state.board);
    if(matches.length === 0){
      locked = false; updateHUD(); return;
    }
    const specialMap = detectSpecials(matches);
    const removeSet = new Set();
    matches.forEach(run=> run.forEach(i=> removeSet.add(i)));
    const removeIdx = Array.from(removeSet).sort((a,b)=>a-b);
    const removedCount = removeIdx.length;
    state.score += removedCount * 10 * state.combo;
    state.combo++;
    updateHUD();

    // pop animation + particles
    let cx=0, cy=0, cnt=0;
    removeIdx.forEach(i=>{
      const el = cellEls[i].btn;
      if(el){
        const r = el.getBoundingClientRect();
        cx += r.left + r.width/2; cy += r.top + r.height/2; cnt++;
        el.classList.add('pop');
      }
      state.board[i] = null;
    });
    if(cnt>0){
      const gx = cx/cnt - gridWrap.getBoundingClientRect().left;
      const gy = cy/cnt - gridWrap.getBoundingClientRect().top;
      for(let p=0;p<Math.min(14, 4+cnt); p++) createParticle(gx + (Math.random()-0.5)*40, gy + (Math.random()-0.5)*40);
    }

    // after pop animation, apply gravity + refill
    setTimeout(()=>{
      // gravity per column
      const cols = [];
      for(let c=0;c<COLS;c++){
        const col = [];
        for(let r=ROWS-1;r>=0;r--){
          const idx = r*COLS + c;
          if(state.board[idx]) col.push(state.board[idx]);
        }
        cols.push(col);
      }
      const newBoard = new Array(SIZE).fill(null);
      const dropMap = {};
      const oldIds = new Set(state.board.filter(Boolean).map(t=>t.id));
      for(let c=0;c<COLS;c++){
        const col = cols[c];
        while(col.length < ROWS) col.push(randTile());
        for(let r=ROWS-1,i=0;r>=0;r--,i++){
          const tile = col[i];
          newBoard[r*COLS + c] = tile;
          if(!oldIds.has(tile.id)) dropMap[tile.id] = `-${(i+1)*tilePx}px`;
        }
      }
      // place specials
      Object.keys(specialMap).forEach(k=>{
        const idx = Number(k);
        if(newBoard[idx]) newBoard[idx].power = specialMap[k];
      });

      state.board = newBoard;
      fitTiles(); render(dropMap);
      // continue chain (cascade)
      setTimeout(()=> setTimeout(step, 160), parseInt(getComputedStyle(document.documentElement).getPropertyValue('--fall-dur')) || 360);
    }, parseInt(getComputedStyle(document.documentElement).getPropertyValue('--pop-dur')) || 360);
  })();
}

/* ========== INPUT HANDLERS (pointer/touch) ========== */
function onPointerDown(e){
  if(locked) return;
  const el = e.currentTarget;
  el.setPointerCapture && el.setPointerCapture(e.pointerId);
  dragging = true; pointerId = e.pointerId; startIndex = Number(el.dataset.index);
  document.addEventListener('pointermove', onPointerMove);
  document.addEventListener('pointerup', onPointerUp);
}
function onPointerMove(e){
  if(!dragging || e.pointerId !== pointerId) return;
  const target = document.elementFromPoint(e.clientX, e.clientY);
  if(!target) return;
  const cell = target.closest && target.closest('.cell') ? target.closest('.cell') : null;
  if(!cell) return;
  const idx = Number(cell.dataset.index);
  if(Number.isNaN(idx)) return;
  if(isAdjacent(startIndex, idx) && idx !== startIndex){
    // visual swap then check matches
    swapAnimate(startIndex, idx).then(()=>{
      // commit swap in state
      [state.board[startIndex], state.board[idx]] = [state.board[idx], state.board[startIndex]];
      render();
      state.moves = Math.max(0, state.moves - 1);
      updateHUD();
      const matches = findMatches(state.board);
      if(matches.length > 0){
        resolveChain();
      } else {
        // revert after short delay
        setTimeout(()=> {
          swapAnimate(startIndex, idx).then(()=> {
            [state.board[startIndex], state.board[idx]] = [state.board[idx], state.board[startIndex]];
            render();
          });
        }, 260);
      }
    });
    // lock input for small time to avoid multi-swaps
    dragging = false;
  }
}
function onPointerUp(e){
  dragging=false; pointerId=null; startIndex=null;
  document.removeEventListener('pointermove', onPointerMove);
  document.removeEventListener('pointerup', onPointerUp);
}
function isAdjacent(a,b){
  if(a==null||b==null) return false;
  const r1 = Math.floor(a/COLS), c1 = a%COLS, r2 = Math.floor(b/COLS), c2 = b%COLS;
  return Math.abs(r1-r2) + Math.abs(c1-c2) === 1;
}

/* ========== BOMB (place & explode) ========== */
document.getElementById('bombBtn').addEventListener('click', ()=>{
  if(locked) return;
  const valid = state.board.map((t,i)=> t? i:-1).filter(i=> i>=0);
  if(valid.length===0) return;
  const idx = valid[Math.floor(Math.random()*valid.length)];
  state.board[idx] = makeTile(BOMB_SRC || FALLBACK_SRC);
  state.board[idx].power = {type:'bomb'};
  render();
  setTimeout(()=> {
    // explode neighbors
    const removed = new Set();
    const r0 = Math.floor(idx/COLS), c0 = idx%COLS;
    for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++){
      const nr=r0+dr, nc=c0+dc;
      if(nr>=0&&nr<ROWS&&nc>=0&&nc<COLS) removed.add(nr*COLS+nc);
    }
    let cx=0, cy=0, cnt=0;
    Array.from(removed).forEach(i=>{
      const el = cellEls[i].btn;
      if(el){ const rc = el.getBoundingClientRect(); cx+=rc.left+rc.width/2; cy+=rc.top+rc.height/2; cnt++; el.classList.add('pop'); }
      state.board[i] = null;
    });
    if(cnt>0){
      const gx = cx/cnt - gridWrap.getBoundingClientRect().left;
      const gy = cy/cnt - gridWrap.getBoundingClientRect().top;
      for(let p=0;p<18;p++) createParticle(gx + (Math.random()-0.5)*60, gy + (Math.random()-0.5)*60);
    }
    state.score += removed.size * 12;
    updateHUD();
    setTimeout(()=> resolveChain(), 260);
  }, 240);
});

/* ========== INIT & HELPERS ========== */
function initBoard(){
  state.nextId = 1;
  state.board = new Array(SIZE).fill(null).map(()=> randTile());
  // ensure no immediate matches
  let tries=0;
  while(findMatches(state.board).length>0 && tries++ < 1000) state.board = new Array(SIZE).fill(null).map(()=> randTile());
  state.score = 0; state.moves = 40; state.combo = 1;
  fitTiles(); render();
}

/* preload & detect images on GitHub (images/ folder) */
async function start(){
  // try detect available images
  const candidates = IMAGE_FILES.slice();
  const ok = await probeImages(candidates);
  pool = ok.length ? ok : IMAGE_FILES.map(src => src).filter(Boolean);
  if(pool.length === 0) pool = [FALLBACK_SRC];
  imgCountEl.textContent = pool.length;
  // create cells and set canvas size
  createCells();
  resizeCanvas();
  window.addEventListener('resize', ()=> { fitTiles(); render(); resizeCanvas(); });
  initBoard();
  updateHUD();
}

/* tile src -> if missing, fallback */
function probeImages(list){
  return Promise.all(list.map(src => new Promise(res=>{
    const img = new Image();
    img.onload = ()=> res(src);
    img.onerror = ()=> res(null);
    img.src = src;
  }))).then(results => results.filter(Boolean));
}

/* create tile with pool src */
function makeTile(src){
  return { id: state.nextId++, src: src || pool[Math.floor(Math.random()*pool.length)] || FALLBACK_SRC, power:null };
}
function randTile(){ return makeTile(); }

/* shuffle */
document.getElementById('shuffle').addEventListener('click', ()=>{ state.board.sort(()=>Math.random()-0.5); render(); });

/* restart */
document.getElementById('restart').addEventListener('click', ()=> initBoard());

/* start everything */
start();

/* continuous particle tick */
(function particleLoop(){
  tickParticles();
})();

/* expose debug */
window._cm = { state, render, resolveChain, fitTiles };

</script>
</body>
</html>
